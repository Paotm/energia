"use strict";

d3.sankey = function () {
  var sankey = {},
      nodeWidth = 24,
      nodePadding = 30,
      size = [1, 1],
      nodes = [],
      links = [],
      sinksRight = true;

  sankey.nodeWidth = function (_) {
    if (!arguments.length) return nodeWidth;
    nodeWidth = +_;
    return sankey;
  };

  sankey.nodePadding = function (_) {
    if (!arguments.length) return nodePadding;
    nodePadding = +_;
    return sankey;
  };

  sankey.nodes = function (_) {
    if (!arguments.length) return nodes;
    nodes = _;
    return sankey;
  };

  sankey.links = function (_) {
    if (!arguments.length) return links;
    links = _;
    return sankey;
  };

  sankey.size = function (_) {
    if (!arguments.length) return size;
    size = _;
    return sankey;
  };

  sankey.sinksRight = function (_) {
    if (!arguments.length) return sinksRight;
    sinksRight = _;
    return sankey;
  };

  sankey.layout = function (iterations) {
    computeNodeLinks();
    computeNodeValues();
    computeNodeBreadths();
    computeNodeDepths(iterations);
    return sankey;
  };

  sankey.relayout = function () {
    computeLinkDepths();
    return sankey;
  };

  // SVG path data generator, to be used as "d" attribute on "path" element selection.
  sankey.link = function () {
    var curvature = .5;

    function link(d) {
      var xs = d.source.x + d.source.dx,
          xt = d.target.x,
          xi = d3.interpolateNumber(xs, xt),
          xsc = xi(curvature),
          xtc = xi(1 - curvature),
          ys = d.source.y + d.sy + d.dy / 2,
          yt = d.target.y + d.ty + d.dy / 2;

      if (!d.cycleBreaker) {
        return "M" + xs + "," + ys + "C" + xsc + "," + ys + " " + xtc + "," + yt + " " + xt + "," + yt;
      } else {
        var xdelta = 1.5 * d.dy + 0.05 * Math.abs(xs - xt);
        xsc = xs + xdelta;
        xtc = xt - xdelta;
        var xm = xi(0.5);
        var ym = d3.interpolateNumber(ys, yt)(0.5);
        var ydelta = (2 * d.dy + 0.1 * Math.abs(xs - xt) + 0.1 * Math.abs(ys - yt)) * (ym < size[1] / 2 ? -1 : 1);
        return "M" + xs + "," + ys + "C" + xsc + "," + ys + " " + xsc + "," + (ys + ydelta) + " " + xm + "," + (ym + ydelta) + "S" + xtc + "," + yt + " " + xt + "," + yt;
      }
    }

    link.curvature = function (_) {
      if (!arguments.length) return curvature;
      curvature = +_;
      return link;
    };

    return link;
  };

  // Populate the sourceLinks and targetLinks for each node.
  // Also, if the source and target are not objects, assume they are indices.
  function computeNodeLinks() {
    nodes.forEach(function (node) {
      // Links that have this node as source.
      node.sourceLinks = [];
      // Links that have this node as target.
      node.targetLinks = [];
    });
    links.forEach(function (link) {
      var source = link.source,
          target = link.target;
      if (typeof source === "number") source = link.source = nodes[link.source];
      if (typeof target === "number") target = link.target = nodes[link.target];
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
  }

  // Compute the value (size) of each node by summing the associated links.
  function computeNodeValues() {
    nodes.forEach(function (node) {
      node.value = Math.max(d3.sum(node.sourceLinks, value), d3.sum(node.targetLinks, value));
    });
  }

  // Iteratively assign the breadth (x-position) for each node.
  // Nodes are assigned the maximum breadth of incoming neighbors plus one;
  // nodes with no incoming links are assigned breadth zero, while
  // nodes with no outgoing links are assigned the maximum breadth.
  function computeNodeBreadths() {
    var remainingNodes = nodes,
        nextNodes,
        x = 0,
        cantidadCol = 6;

    // Work from left to right.
    // Keep updating the breath (x-position) of nodes that are target of recently updated nodes.

    while (remainingNodes.length && x < nodes.length) {
      nextNodes = [];

      remainingNodes.forEach(function (node) {
        node.x = node.position - 1;
        node.dx = nodeWidth;

        node.sourceLinks.forEach(function (link) {
          if (nextNodes.indexOf(link.target) < 0 && !link.cycleBreaker) {
            nextNodes.push(link.target);
          }
        });
      });

      if (nextNodes.length == remainingNodes.length) {
        // There must be a cycle here. Let's search for a link that breaks it.
        findAndMarkCycleBreaker(nextNodes);
        // Start over.
        // TODO: make this optional?
        return computeNodeBreadths();
      } else {
        remainingNodes = nextNodes;
        ++x;
      }
    }
    // Optionally move pure sinks always to the right.
    // if (sinksRight) {
    //   moveSinksRight(cantidadCol);
    // }
    // scaleNodeBreadths((size[0] - nodeWidth) / (x - 5));
    scaleNodeBreadths((size[0] - nodeWidth) / (cantidadCol - 1));
  }

  // Find a link that breaks a cycle in the graph (if any).
  function findAndMarkCycleBreaker(nodes) {
    // Go through all nodes from the given subset and traverse links searching for cycles.
    var link;
    for (var n = nodes.length - 1; n >= 0; n--) {
      link = depthFirstCycleSearch(nodes[n], []);
      if (link) {
        return link;
      }
    }

    // Depth-first search to find a link that is part of a cycle.
    function depthFirstCycleSearch(cursorNode, path) {
      var target, link;
      for (var n = cursorNode.sourceLinks.length - 1; n >= 0; n--) {
        link = cursorNode.sourceLinks[n];
        if (link.cycleBreaker) {
          // Skip already known cycle breakers.
          continue;
        }

        // Check if target of link makes a cycle in current path.
        target = link.target;
        for (var l = 0; l < path.length; l++) {
          if (path[l].source == target) {
            // We found a cycle. Search for weakest link in cycle
            var weakest = link;
            for (; l < path.length; l++) {
              if (path[l].value < weakest.value) {
                weakest = path[l];
              }
            }
            // Mark weakest link as (known) cycle breaker and abort search.
            weakest.cycleBreaker = true;
            return weakest;
          }
        }

        // Recurse deeper.
        path.push(link);
        link = depthFirstCycleSearch(target, path);
        path.pop();
        // Stop further search if we found a cycle breaker.
        if (link) {
          return link;
        }
      }
    }
  }

  function moveSourcesRight() {
    nodes.forEach(function (node) {
      if (!node.targetLinks.length) {
        node.x = d3.min(node.sourceLinks, function (d) {
          return d.target.x;
        }) - 1;
      }
    });
  }

  function moveSinksRight(x) {
    nodes.forEach(function (node) {
      if (!node.sourceLinks.length) {
        node.x = x - 1;
      }
    });
  }

  function scaleNodeBreadths(kx) {
    nodes.forEach(function (node) {
      node.x *= kx;
    });
  }

  // Compute the depth (y-position) for each node.
  function computeNodeDepths(iterations) {
    // Group nodes by breath.
    var nodesByBreadth = d3.nest().key(function (d) {
      return d.x;
    }).sortKeys(d3.ascending).entries(nodes).map(function (d) {
      return d.values;
    });

    //
    initializeNodeDepth();
    resolveCollisions();
    computeLinkDepths();
    for (var alpha = 1; iterations > 0; --iterations) {
      relaxRightToLeft(alpha *= .99);
      resolveCollisions();
      computeLinkDepths();
      relaxLeftToRight(alpha);
      resolveCollisions();
      computeLinkDepths();
    }

    function initializeNodeDepth() {
      // Calculate vertical scaling factor.
      var ky = d3.min(nodesByBreadth, function (nodes) {
        return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
      });

      nodesByBreadth.forEach(function (nodes) {
        nodes.forEach(function (node, i) {
          node.y = i;
          node.dy = node.value * ky;
        });
      });

      links.forEach(function (link) {
        link.dy = link.value * ky;
      });
    }

    function relaxLeftToRight(alpha) {
      nodesByBreadth.forEach(function (nodes, breadth) {
        nodes.forEach(function (node) {
          if (node.targetLinks.length) {
            // Value-weighted average of the y-position of source node centers linked to this node.
            var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedSource(link) {
        return (link.source.y + link.sy + link.dy / 2) * link.value;
      }
    }

    function relaxRightToLeft(alpha) {
      nodesByBreadth.slice().reverse().forEach(function (nodes) {
        nodes.forEach(function (node) {
          if (node.sourceLinks.length) {
            // Value-weighted average of the y-positions of target nodes linked to this node.
            var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedTarget(link) {
        return (link.target.y + link.ty + link.dy / 2) * link.value;
      }
    }

    function resolveCollisions() {
      nodesByBreadth.forEach(function (nodes) {
        var node,
            dy,
            y0 = 0,
            n = nodes.length,
            i;

        // Push any overlapping nodes down.
        nodes.sort(byValue);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dy = y0 - node.y;
          if (dy > 0) node.y += dy;
          y0 = node.y + node.dy + nodePadding;
        }

        // If the bottommost node goes outside the bounds, push it back up.
        dy = y0 - nodePadding - size[1];
        if (dy > 0) {
          y0 = node.y -= dy;

          // Push any overlapping nodes back up.
          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.y + node.dy + nodePadding - y0;
            if (dy > 0) node.y -= dy;
            y0 = node.y;
          }
        }
      });
    }

    function ascendingDepth(a, b) {
      return a.y - b.y;
    }
  }

  // Compute y-offset of the source endpoint (sy) and target endpoints (ty) of links,
  // relative to the source/target node's y-position.
  function computeLinkDepths() {
    nodes.forEach(function (node) {
      node.sourceLinks.sort(byValue);
      node.targetLinks.sort(byValue);
    });
    nodes.forEach(function (node) {
      var sy = 0,
          ty = 0;
      node.sourceLinks.forEach(function (link) {
        link.sy = sy;
        sy += link.dy;
      });
      node.targetLinks.forEach(function (link) {
        link.ty = ty;
        ty += link.dy;
      });
    });

    function ascendingSourceDepth(a, b) {
      return a.source.y - b.source.y;
    }

    function ascendingTargetDepth(a, b) {
      return a.target.y - b.target.y;
    }
  }

  // Y-position of the middle of a node.
  function center(node) {
    return node.y + node.dy / 2;
  }

  // Value property accessor.
  function value(x) {
    return x.value;
  }

  // Alteración del código
  // Ordena los nodos de mayor a menor en función de su valor
  function byValue(first, second) {
    var firstValue = first.value,
        secondValue = second.value;

    if (firstValue < secondValue) {
      return 1;
    } else if (firstValue > secondValue) {
      return -1;
    }

    return 0;
  }

  return sankey;
};
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQzLXNhbmtleUxvb3AuanMiXSwibmFtZXMiOlsiZDMiLCJzYW5rZXkiLCJub2RlV2lkdGgiLCJub2RlUGFkZGluZyIsInNpemUiLCJub2RlcyIsImxpbmtzIiwic2lua3NSaWdodCIsIl8iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJsYXlvdXQiLCJpdGVyYXRpb25zIiwiY29tcHV0ZU5vZGVMaW5rcyIsImNvbXB1dGVOb2RlVmFsdWVzIiwiY29tcHV0ZU5vZGVCcmVhZHRocyIsImNvbXB1dGVOb2RlRGVwdGhzIiwicmVsYXlvdXQiLCJjb21wdXRlTGlua0RlcHRocyIsImxpbmsiLCJjdXJ2YXR1cmUiLCJkIiwieHMiLCJzb3VyY2UiLCJ4IiwiZHgiLCJ4dCIsInRhcmdldCIsInhpIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJ4c2MiLCJ4dGMiLCJ5cyIsInkiLCJzeSIsImR5IiwieXQiLCJ0eSIsImN5Y2xlQnJlYWtlciIsInhkZWx0YSIsIk1hdGgiLCJhYnMiLCJ4bSIsInltIiwieWRlbHRhIiwiZm9yRWFjaCIsIm5vZGUiLCJzb3VyY2VMaW5rcyIsInRhcmdldExpbmtzIiwicHVzaCIsInZhbHVlIiwibWF4Iiwic3VtIiwicmVtYWluaW5nTm9kZXMiLCJuZXh0Tm9kZXMiLCJjYW50aWRhZENvbCIsInBvc2l0aW9uIiwiaW5kZXhPZiIsImZpbmRBbmRNYXJrQ3ljbGVCcmVha2VyIiwic2NhbGVOb2RlQnJlYWR0aHMiLCJuIiwiZGVwdGhGaXJzdEN5Y2xlU2VhcmNoIiwiY3Vyc29yTm9kZSIsInBhdGgiLCJsIiwid2Vha2VzdCIsInBvcCIsIm1vdmVTb3VyY2VzUmlnaHQiLCJtaW4iLCJtb3ZlU2lua3NSaWdodCIsImt4Iiwibm9kZXNCeUJyZWFkdGgiLCJuZXN0Iiwia2V5Iiwic29ydEtleXMiLCJhc2NlbmRpbmciLCJlbnRyaWVzIiwibWFwIiwidmFsdWVzIiwiaW5pdGlhbGl6ZU5vZGVEZXB0aCIsInJlc29sdmVDb2xsaXNpb25zIiwiYWxwaGEiLCJyZWxheFJpZ2h0VG9MZWZ0IiwicmVsYXhMZWZ0VG9SaWdodCIsImt5IiwiaSIsImJyZWFkdGgiLCJ3ZWlnaHRlZFNvdXJjZSIsImNlbnRlciIsInNsaWNlIiwicmV2ZXJzZSIsIndlaWdodGVkVGFyZ2V0IiwieTAiLCJzb3J0IiwiYnlWYWx1ZSIsImFzY2VuZGluZ0RlcHRoIiwiYSIsImIiLCJhc2NlbmRpbmdTb3VyY2VEZXB0aCIsImFzY2VuZGluZ1RhcmdldERlcHRoIiwiZmlyc3QiLCJzZWNvbmQiLCJmaXJzdFZhbHVlIiwic2Vjb25kVmFsdWUiXSwibWFwcGluZ3MiOiI7O0FBQUFBLEdBQUdDLE1BQUgsR0FBWSxZQUFXO0FBQ3JCLE1BQUlBLFNBQVMsRUFBYjtBQUFBLE1BQ0lDLFlBQVksRUFEaEI7QUFBQSxNQUVJQyxjQUFjLEVBRmxCO0FBQUEsTUFHSUMsT0FBTyxDQUFDLENBQUQsRUFBSSxDQUFKLENBSFg7QUFBQSxNQUlJQyxRQUFRLEVBSlo7QUFBQSxNQUtJQyxRQUFRLEVBTFo7QUFBQSxNQU1JQyxhQUFhLElBTmpCOztBQVFBTixTQUFPQyxTQUFQLEdBQW1CLFVBQVNNLENBQVQsRUFBWTtBQUM3QixRQUFJLENBQUNDLFVBQVVDLE1BQWYsRUFBdUIsT0FBT1IsU0FBUDtBQUN2QkEsZ0JBQVksQ0FBQ00sQ0FBYjtBQUNBLFdBQU9QLE1BQVA7QUFDRCxHQUpEOztBQU1BQSxTQUFPRSxXQUFQLEdBQXFCLFVBQVNLLENBQVQsRUFBWTtBQUMvQixRQUFJLENBQUNDLFVBQVVDLE1BQWYsRUFBdUIsT0FBT1AsV0FBUDtBQUN2QkEsa0JBQWMsQ0FBQ0ssQ0FBZjtBQUNBLFdBQU9QLE1BQVA7QUFDRCxHQUpEOztBQU1BQSxTQUFPSSxLQUFQLEdBQWUsVUFBU0csQ0FBVCxFQUFZO0FBQ3pCLFFBQUksQ0FBQ0MsVUFBVUMsTUFBZixFQUF1QixPQUFPTCxLQUFQO0FBQ3ZCQSxZQUFRRyxDQUFSO0FBQ0EsV0FBT1AsTUFBUDtBQUNELEdBSkQ7O0FBTUFBLFNBQU9LLEtBQVAsR0FBZSxVQUFTRSxDQUFULEVBQVk7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QyxDQUFqQyxFQUFvQztBQUNsQyxhQUFPRCxFQUFFekUsTUFBRixDQUFTVSxDQUFULEdBQWFnRSxFQUFFMUUsTUFBRixDQUFTVSxDQUE3QjtBQUNEOztBQUVELGFBQVNrRSxvQkFBVCxDQUE4QkgsQ0FBOUIsRUFBaUNDLENBQWpDLEVBQW9DO0FBQ2xDLGFBQU9ELEVBQUVyRSxNQUFGLENBQVNNLENBQVQsR0FBYWdFLEVBQUV0RSxNQUFGLENBQVNNLENBQTdCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFdBQVN1RCxNQUFULENBQWdCMUMsSUFBaEIsRUFBc0I7QUFDcEIsV0FBT0EsS0FBS2IsQ0FBTCxHQUFTYSxLQUFLWCxFQUFMLEdBQVUsQ0FBMUI7QUFDRDs7QUFFRDtBQUNBLFdBQVNlLEtBQVQsQ0FBZTFCLENBQWYsRUFBa0I7QUFDaEIsV0FBT0EsRUFBRTBCLEtBQVQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsV0FBUzRDLE9BQVQsQ0FBaUJNLEtBQWpCLEVBQXdCQyxNQUF4QixFQUFnQztBQUM5QixRQUFJQyxhQUFhRixNQUFNbEQsS0FBdkI7QUFBQSxRQUNJcUQsY0FBY0YsT0FBT25ELEtBRHpCOztBQUdBLFFBQUlvRCxhQUFhQyxXQUFqQixFQUE4QjtBQUM1QixhQUFPLENBQVA7QUFDRCxLQUZELE1BRU8sSUFBSUQsYUFBYUMsV0FBakIsRUFBOEI7QUFDbkMsYUFBTyxDQUFDLENBQVI7QUFDRDs7QUFFRCxXQUFPLENBQVA7QUFDRDs7QUFFRCxTQUFPdEcsTUFBUDtBQUNELENBOVpEIiwiZmlsZSI6ImQzLXNhbmtleUxvb3AuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkMy5zYW5rZXkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNhbmtleSA9IHt9LFxuICAgICAgbm9kZVdpZHRoID0gMjQsXG4gICAgICBub2RlUGFkZGluZyA9IDMwLFxuICAgICAgc2l6ZSA9IFsxLCAxXSxcbiAgICAgIG5vZGVzID0gW10sXG4gICAgICBsaW5rcyA9IFtdLFxuICAgICAgc2lua3NSaWdodCA9IHRydWU7XG5cbiAgc2Fua2V5Lm5vZGVXaWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlV2lkdGg7XG4gICAgbm9kZVdpZHRoID0gK187XG4gICAgcmV0dXJuIHNhbmtleTtcbiAgfTtcblxuICBzYW5rZXkubm9kZVBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVBhZGRpbmc7XG4gICAgbm9kZVBhZGRpbmcgPSArXztcbiAgICByZXR1cm4gc2Fua2V5O1xuICB9O1xuXG4gIHNhbmtleS5ub2RlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlcztcbiAgICBub2RlcyA9IF87XG4gICAgcmV0dXJuIHNhbmtleTtcbiAgfTtcblxuICBzYW5rZXkubGlua3MgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua3M7XG4gICAgbGlua3MgPSBfO1xuICAgIHJldHVybiBzYW5rZXk7XG4gIH07XG5cbiAgc2Fua2V5LnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICBzaXplID0gXztcbiAgICByZXR1cm4gc2Fua2V5O1xuICB9O1xuXG4gc2Fua2V5LnNpbmtzUmlnaHQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpbmtzUmlnaHQ7XG4gICAgc2lua3NSaWdodCA9IF87XG4gICAgcmV0dXJuIHNhbmtleTtcbiB9O1xuXG4gIHNhbmtleS5sYXlvdXQgPSBmdW5jdGlvbihpdGVyYXRpb25zKSB7XG4gICAgY29tcHV0ZU5vZGVMaW5rcygpO1xuICAgIGNvbXB1dGVOb2RlVmFsdWVzKCk7XG4gICAgY29tcHV0ZU5vZGVCcmVhZHRocygpO1xuICAgIGNvbXB1dGVOb2RlRGVwdGhzKGl0ZXJhdGlvbnMpO1xuICAgIHJldHVybiBzYW5rZXk7XG4gIH07XG5cbiAgc2Fua2V5LnJlbGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgY29tcHV0ZUxpbmtEZXB0aHMoKTtcbiAgICByZXR1cm4gc2Fua2V5O1xuICB9O1xuXG4gIC8vIFNWRyBwYXRoIGRhdGEgZ2VuZXJhdG9yLCB0byBiZSB1c2VkIGFzIFwiZFwiIGF0dHJpYnV0ZSBvbiBcInBhdGhcIiBlbGVtZW50IHNlbGVjdGlvbi5cbiAgc2Fua2V5LmxpbmsgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VydmF0dXJlID0gLjU7XG5cbiAgICBmdW5jdGlvbiBsaW5rKGQpIHtcbiAgICAgIHZhciB4cyA9IGQuc291cmNlLnggKyBkLnNvdXJjZS5keCxcbiAgICAgICAgICB4dCA9IGQudGFyZ2V0LngsXG4gICAgICAgICAgeGkgPSBkMy5pbnRlcnBvbGF0ZU51bWJlcih4cywgeHQpLFxuICAgICAgICAgIHhzYyA9IHhpKGN1cnZhdHVyZSksXG4gICAgICAgICAgeHRjID0geGkoMSAtIGN1cnZhdHVyZSksXG4gICAgICAgICAgeXMgPSBkLnNvdXJjZS55ICsgZC5zeSArIGQuZHkgLyAyLFxuICAgICAgICAgIHl0ID0gZC50YXJnZXQueSArIGQudHkgKyBkLmR5IC8gMjtcblxuICAgICAgaWYgKCFkLmN5Y2xlQnJlYWtlcikge1xuICAgICAgICByZXR1cm4gXCJNXCIgKyB4cyArIFwiLFwiICsgeXNcbiAgICAgICAgICAgICArIFwiQ1wiICsgeHNjICsgXCIsXCIgKyB5c1xuICAgICAgICAgICAgICsgXCIgXCIgKyB4dGMgKyBcIixcIiArIHl0XG4gICAgICAgICAgICAgKyBcIiBcIiArIHh0ICsgXCIsXCIgKyB5dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ZGVsdGEgPSAoMS41ICogZC5keSArIDAuMDUgKiBNYXRoLmFicyh4cyAtIHh0KSk7XG4gICAgICAgIHhzYyA9IHhzICsgeGRlbHRhO1xuICAgICAgICB4dGMgPSB4dCAtIHhkZWx0YTtcbiAgICAgICAgdmFyIHhtID0geGkoMC41KTtcbiAgICAgICAgdmFyIHltID0gZDMuaW50ZXJwb2xhdGVOdW1iZXIoeXMsIHl0KSgwLjUpO1xuICAgICAgICB2YXIgeWRlbHRhID0gKDIgKiBkLmR5ICsgMC4xICogTWF0aC5hYnMoeHMgLSB4dCkgKyAwLjEgKiBNYXRoLmFicyh5cyAtIHl0KSkgKiAoeW0gPCAoc2l6ZVsxXSAvIDIpID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIFwiTVwiICsgeHMgKyBcIixcIiArIHlzXG4gICAgICAgICAgICAgKyBcIkNcIiArIHhzYyArIFwiLFwiICsgeXNcbiAgICAgICAgICAgICArIFwiIFwiICsgeHNjICsgXCIsXCIgKyAoeXMgKyB5ZGVsdGEpXG4gICAgICAgICAgICAgKyBcIiBcIiArIHhtICsgXCIsXCIgKyAoeW0gKyB5ZGVsdGEpXG4gICAgICAgICAgICAgKyBcIlNcIiArIHh0YyArIFwiLFwiICsgeXRcbiAgICAgICAgICAgICArIFwiIFwiICsgeHQgKyBcIixcIiArIHl0O1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGluay5jdXJ2YXR1cmUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjdXJ2YXR1cmU7XG4gICAgICBjdXJ2YXR1cmUgPSArXztcbiAgICAgIHJldHVybiBsaW5rO1xuICAgIH07XG5cbiAgICByZXR1cm4gbGluaztcbiAgfTtcblxuICAvLyBQb3B1bGF0ZSB0aGUgc291cmNlTGlua3MgYW5kIHRhcmdldExpbmtzIGZvciBlYWNoIG5vZGUuXG4gIC8vIEFsc28sIGlmIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBhcmUgbm90IG9iamVjdHMsIGFzc3VtZSB0aGV5IGFyZSBpbmRpY2VzLlxuICBmdW5jdGlvbiBjb21wdXRlTm9kZUxpbmtzKCkge1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgLy8gTGlua3MgdGhhdCBoYXZlIHRoaXMgbm9kZSBhcyBzb3VyY2UuXG4gICAgICBub2RlLnNvdXJjZUxpbmtzID0gW107XG4gICAgICAvLyBMaW5rcyB0aGF0IGhhdmUgdGhpcyBub2RlIGFzIHRhcmdldC5cbiAgICAgIG5vZGUudGFyZ2V0TGlua3MgPSBbXTtcbiAgICB9KTtcbiAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBsaW5rLnNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQgPSBsaW5rLnRhcmdldDtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm51bWJlclwiKSBzb3VyY2UgPSBsaW5rLnNvdXJjZSA9IG5vZGVzW2xpbmsuc291cmNlXTtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcIm51bWJlclwiKSB0YXJnZXQgPSBsaW5rLnRhcmdldCA9IG5vZGVzW2xpbmsudGFyZ2V0XTtcbiAgICAgIHNvdXJjZS5zb3VyY2VMaW5rcy5wdXNoKGxpbmspO1xuICAgICAgdGFyZ2V0LnRhcmdldExpbmtzLnB1c2gobGluayk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSB2YWx1ZSAoc2l6ZSkgb2YgZWFjaCBub2RlIGJ5IHN1bW1pbmcgdGhlIGFzc29jaWF0ZWQgbGlua3MuXG4gIGZ1bmN0aW9uIGNvbXB1dGVOb2RlVmFsdWVzKCkge1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IE1hdGgubWF4KFxuICAgICAgICBkMy5zdW0obm9kZS5zb3VyY2VMaW5rcywgdmFsdWUpLFxuICAgICAgICBkMy5zdW0obm9kZS50YXJnZXRMaW5rcywgdmFsdWUpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gSXRlcmF0aXZlbHkgYXNzaWduIHRoZSBicmVhZHRoICh4LXBvc2l0aW9uKSBmb3IgZWFjaCBub2RlLlxuICAvLyBOb2RlcyBhcmUgYXNzaWduZWQgdGhlIG1heGltdW0gYnJlYWR0aCBvZiBpbmNvbWluZyBuZWlnaGJvcnMgcGx1cyBvbmU7XG4gIC8vIG5vZGVzIHdpdGggbm8gaW5jb21pbmcgbGlua3MgYXJlIGFzc2lnbmVkIGJyZWFkdGggemVybywgd2hpbGVcbiAgLy8gbm9kZXMgd2l0aCBubyBvdXRnb2luZyBsaW5rcyBhcmUgYXNzaWduZWQgdGhlIG1heGltdW0gYnJlYWR0aC5cbiAgZnVuY3Rpb24gY29tcHV0ZU5vZGVCcmVhZHRocygpIHtcbiAgICB2YXIgcmVtYWluaW5nTm9kZXMgPSBub2RlcyxcbiAgICAgICAgbmV4dE5vZGVzLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgY2FudGlkYWRDb2wgPSA2O1xuXG4gICAgLy8gV29yayBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgLy8gS2VlcCB1cGRhdGluZyB0aGUgYnJlYXRoICh4LXBvc2l0aW9uKSBvZiBub2RlcyB0aGF0IGFyZSB0YXJnZXQgb2YgcmVjZW50bHkgdXBkYXRlZCBub2Rlcy5cblxuICAgIHdoaWxlIChyZW1haW5pbmdOb2Rlcy5sZW5ndGggJiYgeCA8IG5vZGVzLmxlbmd0aCkge1xuICAgICAgbmV4dE5vZGVzID0gW107XG5cbiAgICAgIHJlbWFpbmluZ05vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLnggPSBub2RlLnBvc2l0aW9uIC0gMTtcbiAgICAgICAgbm9kZS5keCA9IG5vZGVXaWR0aDtcblxuICAgICAgICBub2RlLnNvdXJjZUxpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuICAgICAgICAgIGlmIChuZXh0Tm9kZXMuaW5kZXhPZihsaW5rLnRhcmdldCkgPCAwICYmICFsaW5rLmN5Y2xlQnJlYWtlcikge1xuICAgICAgICAgICAgbmV4dE5vZGVzLnB1c2gobGluay50YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5leHROb2Rlcy5sZW5ndGggPT0gcmVtYWluaW5nTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIFRoZXJlIG11c3QgYmUgYSBjeWNsZSBoZXJlLiBMZXQncyBzZWFyY2ggZm9yIGEgbGluayB0aGF0IGJyZWFrcyBpdC5cbiAgICAgICAgZmluZEFuZE1hcmtDeWNsZUJyZWFrZXIobmV4dE5vZGVzKTtcbiAgICAgICAgLy8gU3RhcnQgb3Zlci5cbiAgICAgICAgLy8gVE9ETzogbWFrZSB0aGlzIG9wdGlvbmFsP1xuICAgICAgICByZXR1cm4gY29tcHV0ZU5vZGVCcmVhZHRocygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nTm9kZXMgPSBuZXh0Tm9kZXM7XG4gICAgICAgICsreDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT3B0aW9uYWxseSBtb3ZlIHB1cmUgc2lua3MgYWx3YXlzIHRvIHRoZSByaWdodC5cbiAgICAvLyBpZiAoc2lua3NSaWdodCkge1xuICAgIC8vICAgbW92ZVNpbmtzUmlnaHQoY2FudGlkYWRDb2wpO1xuICAgIC8vIH1cbiAgICAvLyBzY2FsZU5vZGVCcmVhZHRocygoc2l6ZVswXSAtIG5vZGVXaWR0aCkgLyAoeCAtIDUpKTtcbiAgICBzY2FsZU5vZGVCcmVhZHRocygoc2l6ZVswXSAtIG5vZGVXaWR0aCkgLyAoY2FudGlkYWRDb2wgLSAxKSk7XG4gIH1cblxuICAvLyBGaW5kIGEgbGluayB0aGF0IGJyZWFrcyBhIGN5Y2xlIGluIHRoZSBncmFwaCAoaWYgYW55KS5cbiAgZnVuY3Rpb24gZmluZEFuZE1hcmtDeWNsZUJyZWFrZXIobm9kZXMpIHtcbiAgLy8gR28gdGhyb3VnaCBhbGwgbm9kZXMgZnJvbSB0aGUgZ2l2ZW4gc3Vic2V0IGFuZCB0cmF2ZXJzZSBsaW5rcyBzZWFyY2hpbmcgZm9yIGN5Y2xlcy5cbiAgICB2YXIgbGluaztcbiAgICBmb3IgKHZhciBuPW5vZGVzLmxlbmd0aCAtIDE7IG4gPj0gMDsgbi0tKSB7XG4gICAgICBsaW5rID0gZGVwdGhGaXJzdEN5Y2xlU2VhcmNoKG5vZGVzW25dLCBbXSk7XG4gICAgICBpZiAobGluaykge1xuICAgICAgICByZXR1cm4gbGluaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZXB0aC1maXJzdCBzZWFyY2ggdG8gZmluZCBhIGxpbmsgdGhhdCBpcyBwYXJ0IG9mIGEgY3ljbGUuXG4gICAgZnVuY3Rpb24gZGVwdGhGaXJzdEN5Y2xlU2VhcmNoKGN1cnNvck5vZGUsIHBhdGgpIHtcbiAgICAgIHZhciB0YXJnZXQsIGxpbms7XG4gICAgICBmb3IgKHZhciBuID0gY3Vyc29yTm9kZS5zb3VyY2VMaW5rcy5sZW5ndGggLSAxOyBuID49IDA7IG4tLSkge1xuICAgICAgICBsaW5rID0gY3Vyc29yTm9kZS5zb3VyY2VMaW5rc1tuXTtcbiAgICAgICAgaWYgKGxpbmsuY3ljbGVCcmVha2VyKSB7XG4gICAgICAgICAgLy8gU2tpcCBhbHJlYWR5IGtub3duIGN5Y2xlIGJyZWFrZXJzLlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IG9mIGxpbmsgbWFrZXMgYSBjeWNsZSBpbiBjdXJyZW50IHBhdGguXG4gICAgICAgIHRhcmdldCA9IGxpbmsudGFyZ2V0O1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHBhdGgubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICBpZiAocGF0aFtsXS5zb3VyY2UgPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIGN5Y2xlLiBTZWFyY2ggZm9yIHdlYWtlc3QgbGluayBpbiBjeWNsZVxuICAgICAgICAgICAgdmFyIHdlYWtlc3QgPSBsaW5rO1xuICAgICAgICAgICAgZm9yICg7IGwgPCBwYXRoLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgIGlmIChwYXRoW2xdLnZhbHVlIDwgd2Vha2VzdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHdlYWtlc3QgPSBwYXRoW2xdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYXJrIHdlYWtlc3QgbGluayBhcyAoa25vd24pIGN5Y2xlIGJyZWFrZXIgYW5kIGFib3J0IHNlYXJjaC5cbiAgICAgICAgICAgIHdlYWtlc3QuY3ljbGVCcmVha2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB3ZWFrZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY3Vyc2UgZGVlcGVyLlxuICAgICAgICBwYXRoLnB1c2gobGluayk7XG4gICAgICAgIGxpbmsgPSBkZXB0aEZpcnN0Q3ljbGVTZWFyY2godGFyZ2V0LCBwYXRoKTtcbiAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgLy8gU3RvcCBmdXJ0aGVyIHNlYXJjaCBpZiB3ZSBmb3VuZCBhIGN5Y2xlIGJyZWFrZXIuXG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG1vdmVTb3VyY2VzUmlnaHQoKSB7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAoIW5vZGUudGFyZ2V0TGlua3MubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUueCA9IGQzLm1pbihub2RlLnNvdXJjZUxpbmtzLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnRhcmdldC54OyB9KSAtIDE7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlU2lua3NSaWdodCh4KSB7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAoIW5vZGUuc291cmNlTGlua3MubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUueCA9IHggLSAxO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGVOb2RlQnJlYWR0aHMoa3gpIHtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUueCAqPSBreDtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGRlcHRoICh5LXBvc2l0aW9uKSBmb3IgZWFjaCBub2RlLlxuICBmdW5jdGlvbiBjb21wdXRlTm9kZURlcHRocyhpdGVyYXRpb25zKSB7XG4gICAgLy8gR3JvdXAgbm9kZXMgYnkgYnJlYXRoLlxuICAgIHZhciBub2Rlc0J5QnJlYWR0aCA9IGQzLm5lc3QoKVxuICAgICAgICAua2V5KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueDsgfSlcbiAgICAgICAgLnNvcnRLZXlzKGQzLmFzY2VuZGluZylcbiAgICAgICAgLmVudHJpZXMobm9kZXMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXM7IH0pO1xuXG4gICAgLy9cbiAgICBpbml0aWFsaXplTm9kZURlcHRoKCk7XG4gICAgcmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgICBjb21wdXRlTGlua0RlcHRocygpO1xuICAgIGZvciAodmFyIGFscGhhID0gMTsgaXRlcmF0aW9ucyA+IDA7IC0taXRlcmF0aW9ucykge1xuICAgICAgcmVsYXhSaWdodFRvTGVmdChhbHBoYSAqPSAuOTkpO1xuICAgICAgcmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgICAgIGNvbXB1dGVMaW5rRGVwdGhzKCk7XG4gICAgICByZWxheExlZnRUb1JpZ2h0KGFscGhhKTtcbiAgICAgIHJlc29sdmVDb2xsaXNpb25zKCk7XG4gICAgICBjb21wdXRlTGlua0RlcHRocygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVOb2RlRGVwdGgoKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgdmVydGljYWwgc2NhbGluZyBmYWN0b3IuXG4gICAgICB2YXIga3kgPSBkMy5taW4obm9kZXNCeUJyZWFkdGgsIGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICAgIHJldHVybiAoc2l6ZVsxXSAtIChub2Rlcy5sZW5ndGggLSAxKSAqIG5vZGVQYWRkaW5nKSAvIGQzLnN1bShub2RlcywgdmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlLCBpKSB7XG4gICAgICAgICAgbm9kZS55ID0gaTtcbiAgICAgICAgICBub2RlLmR5ID0gbm9kZS52YWx1ZSAqIGt5O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgbGluay5keSA9IGxpbmsudmFsdWUgKiBreTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF4TGVmdFRvUmlnaHQoYWxwaGEpIHtcbiAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24obm9kZXMsIGJyZWFkdGgpIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUudGFyZ2V0TGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBWYWx1ZS13ZWlnaHRlZCBhdmVyYWdlIG9mIHRoZSB5LXBvc2l0aW9uIG9mIHNvdXJjZSBub2RlIGNlbnRlcnMgbGlua2VkIHRvIHRoaXMgbm9kZS5cbiAgICAgICAgICAgIHZhciB5ID0gZDMuc3VtKG5vZGUudGFyZ2V0TGlua3MsIHdlaWdodGVkU291cmNlKSAvIGQzLnN1bShub2RlLnRhcmdldExpbmtzLCB2YWx1ZSk7XG4gICAgICAgICAgICBub2RlLnkgKz0gKHkgLSBjZW50ZXIobm9kZSkpICogYWxwaGE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiB3ZWlnaHRlZFNvdXJjZShsaW5rKSB7XG4gICAgICAgIHJldHVybiAobGluay5zb3VyY2UueSArIGxpbmsuc3kgKyBsaW5rLmR5IC8gMikgKiBsaW5rLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF4UmlnaHRUb0xlZnQoYWxwaGEpIHtcbiAgICAgIG5vZGVzQnlCcmVhZHRoLnNsaWNlKCkucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUuc291cmNlTGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBWYWx1ZS13ZWlnaHRlZCBhdmVyYWdlIG9mIHRoZSB5LXBvc2l0aW9ucyBvZiB0YXJnZXQgbm9kZXMgbGlua2VkIHRvIHRoaXMgbm9kZS5cbiAgICAgICAgICAgIHZhciB5ID0gZDMuc3VtKG5vZGUuc291cmNlTGlua3MsIHdlaWdodGVkVGFyZ2V0KSAvIGQzLnN1bShub2RlLnNvdXJjZUxpbmtzLCB2YWx1ZSk7XG4gICAgICAgICAgICBub2RlLnkgKz0gKHkgLSBjZW50ZXIobm9kZSkpICogYWxwaGE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiB3ZWlnaHRlZFRhcmdldChsaW5rKSB7XG4gICAgICAgIHJldHVybiAobGluay50YXJnZXQueSArIGxpbmsudHkgKyBsaW5rLmR5IC8gMikgKiBsaW5rLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVDb2xsaXNpb25zKCkge1xuICAgICAgbm9kZXNCeUJyZWFkdGguZm9yRWFjaChmdW5jdGlvbihub2Rlcykge1xuICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICAgIGR5LFxuICAgICAgICAgICAgeTAgPSAwLFxuICAgICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gUHVzaCBhbnkgb3ZlcmxhcHBpbmcgbm9kZXMgZG93bi5cbiAgICAgICAgbm9kZXMuc29ydChieVZhbHVlKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBkeSA9IHkwIC0gbm9kZS55O1xuICAgICAgICAgIGlmIChkeSA+IDApIG5vZGUueSArPSBkeTtcbiAgICAgICAgICB5MCA9IG5vZGUueSArIG5vZGUuZHkgKyBub2RlUGFkZGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBib3R0b21tb3N0IG5vZGUgZ29lcyBvdXRzaWRlIHRoZSBib3VuZHMsIHB1c2ggaXQgYmFjayB1cC5cbiAgICAgICAgZHkgPSB5MCAtIG5vZGVQYWRkaW5nIC0gc2l6ZVsxXTtcbiAgICAgICAgaWYgKGR5ID4gMCkge1xuICAgICAgICAgIHkwID0gbm9kZS55IC09IGR5O1xuXG4gICAgICAgICAgLy8gUHVzaCBhbnkgb3ZlcmxhcHBpbmcgbm9kZXMgYmFjayB1cC5cbiAgICAgICAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGR5ID0gbm9kZS55ICsgbm9kZS5keSArIG5vZGVQYWRkaW5nIC0geTA7XG4gICAgICAgICAgICBpZiAoZHkgPiAwKSBub2RlLnkgLT0gZHk7XG4gICAgICAgICAgICB5MCA9IG5vZGUueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzY2VuZGluZ0RlcHRoKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnkgLSBiLnk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB5LW9mZnNldCBvZiB0aGUgc291cmNlIGVuZHBvaW50IChzeSkgYW5kIHRhcmdldCBlbmRwb2ludHMgKHR5KSBvZiBsaW5rcyxcbiAgLy8gcmVsYXRpdmUgdG8gdGhlIHNvdXJjZS90YXJnZXQgbm9kZSdzIHktcG9zaXRpb24uXG4gIGZ1bmN0aW9uIGNvbXB1dGVMaW5rRGVwdGhzKCkge1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS5zb3VyY2VMaW5rcy5zb3J0KGJ5VmFsdWUpO1xuICAgICAgbm9kZS50YXJnZXRMaW5rcy5zb3J0KGJ5VmFsdWUpO1xuICAgIH0pO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHN5ID0gMCwgdHkgPSAwO1xuICAgICAgbm9kZS5zb3VyY2VMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgbGluay5zeSA9IHN5O1xuICAgICAgICBzeSArPSBsaW5rLmR5O1xuICAgICAgfSk7XG4gICAgICBub2RlLnRhcmdldExpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuICAgICAgICBsaW5rLnR5ID0gdHk7XG4gICAgICAgIHR5ICs9IGxpbmsuZHk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFzY2VuZGluZ1NvdXJjZURlcHRoKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnNvdXJjZS55IC0gYi5zb3VyY2UueTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc2NlbmRpbmdUYXJnZXREZXB0aChhLCBiKSB7XG4gICAgICByZXR1cm4gYS50YXJnZXQueSAtIGIudGFyZ2V0Lnk7XG4gICAgfVxuICB9XG5cbiAgLy8gWS1wb3NpdGlvbiBvZiB0aGUgbWlkZGxlIG9mIGEgbm9kZS5cbiAgZnVuY3Rpb24gY2VudGVyKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS55ICsgbm9kZS5keSAvIDI7XG4gIH1cblxuICAvLyBWYWx1ZSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgZnVuY3Rpb24gdmFsdWUoeCkge1xuICAgIHJldHVybiB4LnZhbHVlO1xuICB9XG5cbiAgLy8gQWx0ZXJhY2nDs24gZGVsIGPDs2RpZ29cbiAgLy8gT3JkZW5hIGxvcyBub2RvcyBkZSBtYXlvciBhIG1lbm9yIGVuIGZ1bmNpw7NuIGRlIHN1IHZhbG9yXG4gIGZ1bmN0aW9uIGJ5VmFsdWUoZmlyc3QsIHNlY29uZCkge1xuICAgIGxldCBmaXJzdFZhbHVlID0gZmlyc3QudmFsdWUsXG4gICAgICAgIHNlY29uZFZhbHVlID0gc2Vjb25kLnZhbHVlO1xuXG4gICAgaWYgKGZpcnN0VmFsdWUgPCBzZWNvbmRWYWx1ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChmaXJzdFZhbHVlID4gc2Vjb25kVmFsdWUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzYW5rZXk7XG59O1xuIl19
