"use strict";

d3.sankey = function () {
  var sankey = {},
      nodeWidth = 24,
      nodePadding = 30,
      size = [1, 1],
      nodes = [],
      links = [],
      sinksRight = true;

  sankey.nodeWidth = function (_) {
    if (!arguments.length) return nodeWidth;
    nodeWidth = +_;
    return sankey;
  };

  sankey.nodePadding = function (_) {
    if (!arguments.length) return nodePadding;
    nodePadding = +_;
    return sankey;
  };

  sankey.nodes = function (_) {
    if (!arguments.length) return nodes;
    nodes = _;
    return sankey;
  };

  sankey.links = function (_) {
    if (!arguments.length) return links;
    links = _;
    return sankey;
  };

  sankey.size = function (_) {
    if (!arguments.length) return size;
    size = _;
    return sankey;
  };

  sankey.sinksRight = function (_) {
    if (!arguments.length) return sinksRight;
    sinksRight = _;
    return sankey;
  };

  sankey.layout = function (iterations) {
    computeNodeLinks();
    computeNodeValues();
    computeNodeBreadths();
    computeNodeDepths(iterations);
    return sankey;
  };

  sankey.relayout = function () {
    computeLinkDepths();
    return sankey;
  };

  // SVG path data generator, to be used as "d" attribute on "path" element selection.
  sankey.link = function () {
    var curvature = .5;

    function link(d) {
      var xs = d.source.x + d.source.dx,
          xt = d.target.x,
          xi = d3.interpolateNumber(xs, xt),
          xsc = xi(curvature),
          xtc = xi(1 - curvature),
          ys = d.source.y + d.sy + d.dy / 2,
          yt = d.target.y + d.ty + d.dy / 2;

      if (!d.cycleBreaker) {
        return "M" + xs + "," + ys + "C" + xsc + "," + ys + " " + xtc + "," + yt + " " + xt + "," + yt;
      } else {
        var xdelta = 1.5 * d.dy + 0.05 * Math.abs(xs - xt);
        xsc = xs + xdelta;
        xtc = xt - xdelta;
        var xm = xi(0.5);
        var ym = d3.interpolateNumber(ys, yt)(0.5);
        var ydelta = (2 * d.dy + 0.1 * Math.abs(xs - xt) + 0.1 * Math.abs(ys - yt)) * (ym < size[1] / 2 ? -1 : 1);
        return "M" + xs + "," + ys + "C" + xsc + "," + ys + " " + xsc + "," + (ys + ydelta) + " " + xm + "," + (ym + ydelta) + "S" + xtc + "," + yt + " " + xt + "," + yt;
      }
    }

    link.curvature = function (_) {
      if (!arguments.length) return curvature;
      curvature = +_;
      return link;
    };

    return link;
  };

  // Populate the sourceLinks and targetLinks for each node.
  // Also, if the source and target are not objects, assume they are indices.
  function computeNodeLinks() {
    nodes.forEach(function (node) {
      // Links that have this node as source.
      node.sourceLinks = [];
      // Links that have this node as target.
      node.targetLinks = [];
    });
    links.forEach(function (link) {
      var source = link.source,
          target = link.target;
      if (typeof source === "number") source = link.source = nodes[link.source];
      if (typeof target === "number") target = link.target = nodes[link.target];
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
  }

  // Compute the value (size) of each node by summing the associated links.
  function computeNodeValues() {
    nodes.forEach(function (node) {
      node.value = Math.max(d3.sum(node.sourceLinks, value), d3.sum(node.targetLinks, value));
    });
  }

  // Iteratively assign the breadth (x-position) for each node.
  // Nodes are assigned the maximum breadth of incoming neighbors plus one;
  // nodes with no incoming links are assigned breadth zero, while
  // nodes with no outgoing links are assigned the maximum breadth.
  function computeNodeBreadths() {
    var remainingNodes = nodes,
        nextNodes,
        x = 0,
        cantidadCol = 4;

    // Work from left to right.
    // Keep updating the breath (x-position) of nodes that are target of recently updated nodes.

    while (remainingNodes.length && x < nodes.length) {
      nextNodes = [];

      remainingNodes.forEach(function (node) {
        node.x = node.pos - 1;
        node.dx = nodeWidth;

        node.sourceLinks.forEach(function (link) {
          if (nextNodes.indexOf(link.target) < 0 && !link.cycleBreaker) {
            nextNodes.push(link.target);
          }
        });
      });

      if (nextNodes.length == remainingNodes.length) {
        // There must be a cycle here. Let's search for a link that breaks it.
        findAndMarkCycleBreaker(nextNodes);
        // Start over.
        // TODO: make this optional?
        return computeNodeBreadths();
      } else {
        remainingNodes = nextNodes;
        ++x;
      }
    }
    // Optionally move pure sinks always to the right.
    // if (sinksRight) {
    //   moveSinksRight(cantidadCol);
    // }
    // scaleNodeBreadths((size[0] - nodeWidth) / (x - 5));
    scaleNodeBreadths((size[0] - nodeWidth) / (cantidadCol - 1));
  }

  // Find a link that breaks a cycle in the graph (if any).
  function findAndMarkCycleBreaker(nodes) {
    // Go through all nodes from the given subset and traverse links searching for cycles.
    var link;
    for (var n = nodes.length - 1; n >= 0; n--) {
      link = depthFirstCycleSearch(nodes[n], []);
      if (link) {
        return link;
      }
    }

    // Depth-first search to find a link that is part of a cycle.
    function depthFirstCycleSearch(cursorNode, path) {
      var target, link;
      for (var n = cursorNode.sourceLinks.length - 1; n >= 0; n--) {
        link = cursorNode.sourceLinks[n];
        if (link.cycleBreaker) {
          // Skip already known cycle breakers.
          continue;
        }

        // Check if target of link makes a cycle in current path.
        target = link.target;
        for (var l = 0; l < path.length; l++) {
          if (path[l].source == target) {
            // We found a cycle. Search for weakest link in cycle
            var weakest = link;
            for (; l < path.length; l++) {
              if (path[l].value < weakest.value) {
                weakest = path[l];
              }
            }
            // Mark weakest link as (known) cycle breaker and abort search.
            weakest.cycleBreaker = true;
            return weakest;
          }
        }

        // Recurse deeper.
        path.push(link);
        link = depthFirstCycleSearch(target, path);
        path.pop();
        // Stop further search if we found a cycle breaker.
        if (link) {
          return link;
        }
      }
    }
  }

  function moveSourcesRight() {
    nodes.forEach(function (node) {
      if (!node.targetLinks.length) {
        node.x = d3.min(node.sourceLinks, function (d) {
          return d.target.x;
        }) - 1;
      }
    });
  }

  function moveSinksRight(x) {
    nodes.forEach(function (node) {
      if (!node.sourceLinks.length) {
        node.x = x - 1;
      }
    });
  }

  function scaleNodeBreadths(kx) {
    nodes.forEach(function (node) {
      node.x *= kx;
    });
  }

  // Compute the depth (y-position) for each node.
  function computeNodeDepths(iterations) {
    // Group nodes by breath.
    var nodesByBreadth = d3.nest().key(function (d) {
      return d.x;
    }).sortKeys(d3.ascending).entries(nodes).map(function (d) {
      return d.values;
    });

    //
    initializeNodeDepth();
    resolveCollisions();
    computeLinkDepths();
    for (var alpha = 1; iterations > 0; --iterations) {
      relaxRightToLeft(alpha *= .99);
      resolveCollisions();
      computeLinkDepths();
      relaxLeftToRight(alpha);
      resolveCollisions();
      computeLinkDepths();
    }

    function initializeNodeDepth() {
      // Calculate vertical scaling factor.
      var ky = d3.min(nodesByBreadth, function (nodes) {
        return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
      });

      nodesByBreadth.forEach(function (nodes) {
        nodes.forEach(function (node, i) {
          node.y = i;
          node.dy = node.value * ky;
        });
      });

      links.forEach(function (link) {
        link.dy = link.value * ky;
      });
    }

    function relaxLeftToRight(alpha) {
      nodesByBreadth.forEach(function (nodes, breadth) {
        nodes.forEach(function (node) {
          if (node.targetLinks.length) {
            // Value-weighted average of the y-position of source node centers linked to this node.
            var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedSource(link) {
        return (link.source.y + link.sy + link.dy / 2) * link.value;
      }
    }

    function relaxRightToLeft(alpha) {
      nodesByBreadth.slice().reverse().forEach(function (nodes) {
        nodes.forEach(function (node) {
          if (node.sourceLinks.length) {
            // Value-weighted average of the y-positions of target nodes linked to this node.
            var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedTarget(link) {
        return (link.target.y + link.ty + link.dy / 2) * link.value;
      }
    }

    function resolveCollisions() {
      nodesByBreadth.forEach(function (nodes) {
        var node,
            dy,
            y0 = 0,
            n = nodes.length,
            i;

        // Push any overlapping nodes down.
        nodes.sort(byValue);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dy = y0 - node.y;
          if (dy > 0) node.y += dy;
          y0 = node.y + node.dy + nodePadding;
        }

        // If the bottommost node goes outside the bounds, push it back up.
        dy = y0 - nodePadding - size[1];
        if (dy > 0) {
          y0 = node.y -= dy;

          // Push any overlapping nodes back up.
          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.y + node.dy + nodePadding - y0;
            if (dy > 0) node.y -= dy;
            y0 = node.y;
          }
        }
      });
    }

    function ascendingDepth(a, b) {
      return a.y - b.y;
    }
  }

  // Compute y-offset of the source endpoint (sy) and target endpoints (ty) of links,
  // relative to the source/target node's y-position.
  function computeLinkDepths() {
    nodes.forEach(function (node) {
      node.sourceLinks.sort(byValue);
      node.targetLinks.sort(byValue);
    });
    nodes.forEach(function (node) {
      var sy = 0,
          ty = 0;
      node.sourceLinks.forEach(function (link) {
        link.sy = sy;
        sy += link.dy;
      });
      node.targetLinks.forEach(function (link) {
        link.ty = ty;
        ty += link.dy;
      });
    });

    function ascendingSourceDepth(a, b) {
      return a.source.y - b.source.y;
    }

    function ascendingTargetDepth(a, b) {
      return a.target.y - b.target.y;
    }
  }

  // Y-position of the middle of a node.
  function center(node) {
    return node.y + node.dy / 2;
  }

  // Value property accessor.
  function value(x) {
    return x.value;
  }

  // Alteración del código
  // Ordena los nodos de mayor a menor en función de su valor
  function byValue(first, second) {
    var firstValue = first.value,
        secondValue = second.value;

    if (firstValue < secondValue) {
      return 1;
    } else if (firstValue > secondValue) {
      return -1;
    }

    return 0;
  }

  return sankey;
};
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQzLXNhbmtleUxvb3AuanMiXSwibmFtZXMiOlsiZDMiLCJzYW5rZXkiLCJub2RlV2lkdGgiLCJub2RlUGFkZGluZyIsInNpemUiLCJub2RlcyIsImxpbmtzIiwic2lua3NSaWdodCIsIl8iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJsYXlvdXQiLCJpdGVyYXRpb25zIiwiY29tcHV0ZU5vZGVMaW5rcyIsImNvbXB1dGVOb2RlVmFsdWVzIiwiY29tcHV0ZU5vZGVCcmVhZHRocyIsImNvbXB1dGVOb2RlRGVwdGhzIiwicmVsYXlvdXQiLCJjb21wdXRlTGlua0RlcHRocyIsImxpbmsiLCJjdXJ2YXR1cmUiLCJkIiwieHMiLCJzb3VyY2UiLCJ4IiwiZHgiLCJ4dCIsInRhcmdldCIsInhpIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJ4c2MiLCJ4dGMiLCJ5cyIsInkiLCJzeSIsImR5IiwieXQiLCJ0eSIsImN5Y2xlQnJlYWtlciIsInhkZWx0YSIsIk1hdGgiLCJhYnMiLCJ4bSIsInltIiwieWRlbHRhIiwiZm9yRWFjaCIsIm5vZGUiLCJzb3VyY2VMaW5rcyIsInRhcmdldExpbmtzIiwicHVzaCIsInZhbHVlIiwibWF4Iiwic3VtIiwicmVtYWluaW5nTm9kZXMiLCJuZXh0Tm9kZXMiLCJjYW50aWRhZENvbCIsInBvcyIsImluZGV4T2YiLCJmaW5kQW5kTWFya0N5Y2xlQnJlYWtlciIsInNjYWxlTm9kZUJyZWFkdGhzIiwibiIsImRlcHRoRmlyc3RDeWNsZVNlYXJjaCIsImN1cnNvck5vZGUiLCJwYXRoIiwibCIsIndlYWtlc3QiLCJwb3AiLCJtb3ZlU291cmNlc1JpZ2h0IiwibWluIiwibW92ZVNpbmtzUmlnaHQiLCJreCIsIm5vZGVzQnlCcmVhZHRoIiwibmVzdCIsImtleSIsInNvcnRLZXlzIiwiYXNjZW5kaW5nIiwiZW50cmllcyIsIm1hcCIsInZhbHVlcyIsImluaXRpYWxpemVOb2RlRGVwdGgiLCJyZXNvbHZlQ29sbGlzaW9ucyIsImFscGhhIiwicmVsYXhSaWdodFRvTGVmdCIsInJlbGF4TGVmdFRvUmlnaHQiLCJreSIsImkiLCJicmVhZHRoIiwid2VpZ2h0ZWRTb3VyY2UiLCJjZW50ZXIiLCJzbGljZSIsInJldmVyc2UiLCJ3ZWlnaHRlZFRhcmdldCIsInkwIiwic29ydCIsImJ5VmFsdWUiLCJhc2NlbmRpbmdEZXB0aCIsImEiLCJiIiwiYXNjZW5kaW5nU291cmNlRGVwdGgiLCJhc2NlbmRpbmdUYXJnZXREZXB0aCIsImZpcnN0Iiwic2Vjb25kIiwiZmlyc3RWYWx1ZSIsInNlY29uZFZhbHVlIl0sIm1hcHBpbmdzIjoiOztBQUFBQSxHQUFHQyxNQUFILEdBQVksWUFBVztBQUNyQixNQUFJQSxTQUFTLEVBQWI7QUFBQSxNQUNJQyxZQUFZLEVBRGhCO0FBQUEsTUFFSUMsY0FBYyxFQUZsQjtBQUFBLE1BR0lDLE9BQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixDQUhYO0FBQUEsTUFJSUMsUUFBUSxFQUpaO0FBQUEsTUFLSUMsUUFBUSxFQUxaO0FBQUEsTUFNSUMsYUFBYSxJQU5qQjs7QUFRQU4sU0FBT0MsU0FBUCxHQUFtQixVQUFTTSxDQUFULEVBQVk7QUFDN0IsUUFBSSxDQUFDQyxVQUFVQyxNQUFmLEVBQXVCLE9BQU9SLFNBQVA7QUFDdkJBLGdCQUFZLENBQUNNLENBQWI7QUFDQSxXQUFPUCxNQUFQO0FBQ0QsR0FKRDs7QUFNQUEsU0FBT0UsV0FBUCxHQUFxQixVQUFTSyxDQUFULEVBQVk7QUFDL0IsUUFBSSxDQUFDQyxVQUFVQyxNQUFmLEVBQXVCLE9BQU9QLFdBQVA7QUFDdkJBLGtCQUFjLENBQUNLLENBQWY7QUFDQSxXQUFPUCxNQUFQO0FBQ0QsR0FKRDs7QUFNQUEsU0FBT0ksS0FBUCxHQUFlLFVBQVNHLENBQVQsRUFBWTtBQUN6QixRQUFJLENBQUNDLFVBQVVDLE1BQWYsRUFBdUIsT0FBT0wsS0FBUDtBQUN2QkEsWUFBUUcsQ0FBUjtBQUNBLFdBQU9QLE1BQVA7QUFDRCxHQUpEOztBQU1BQSxTQUFPSyxLQUFQLEdBQWUsVUFBU0UsQ0FBVCxFQUFZO0FBQ3pC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QyxFQUFvQztBQUNsQyxhQUFPRCxFQUFFekUsTUFBRixDQUFTVSxDQUFULEdBQWFnRSxFQUFFMUUsTUFBRixDQUFTVSxDQUE3QjtBQUNEOztBQUVELGFBQVNrRSxvQkFBVCxDQUE4QkgsQ0FBOUIsRUFBaUNDLENBQWpDLEVBQW9DO0FBQ2xDLGFBQU9ELEVBQUVyRSxNQUFGLENBQVNNLENBQVQsR0FBYWdFLEVBQUV0RSxNQUFGLENBQVNNLENBQTdCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFdBQVN1RCxNQUFULENBQWdCMUMsSUFBaEIsRUFBc0I7QUFDcEIsV0FBT0EsS0FBS2IsQ0FBTCxHQUFTYSxLQUFLWCxFQUFMLEdBQVUsQ0FBMUI7QUFDRDs7QUFFRDtBQUNBLFdBQVNlLEtBQVQsQ0FBZTFCLENBQWYsRUFBa0I7QUFDaEIsV0FBT0EsRUFBRTBCLEtBQVQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsV0FBUzRDLE9BQVQsQ0FBaUJNLEtBQWpCLEVBQXdCQyxNQUF4QixFQUFnQztBQUM5QixRQUFJQyxhQUFhRixNQUFNbEQsS0FBdkI7QUFBQSxRQUNJcUQsY0FBY0YsT0FBT25ELEtBRHpCOztBQUdBLFFBQUlvRCxhQUFhQyxXQUFqQixFQUE4QjtBQUM1QixhQUFPLENBQVA7QUFDRCxLQUZELE1BRU8sSUFBSUQsYUFBYUMsV0FBakIsRUFBOEI7QUFDbkMsYUFBTyxDQUFDLENBQVI7QUFDRDs7QUFFRCxXQUFPLENBQVA7QUFDRDs7QUFFRCxTQUFPdEcsTUFBUDtBQUNELENBOVpEIiwiZmlsZSI6ImQzLXNhbmtleUxvb3AuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkMy5zYW5rZXkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNhbmtleSA9IHt9LFxuICAgICAgbm9kZVdpZHRoID0gMjQsXG4gICAgICBub2RlUGFkZGluZyA9IDMwLFxuICAgICAgc2l6ZSA9IFsxLCAxXSxcbiAgICAgIG5vZGVzID0gW10sXG4gICAgICBsaW5rcyA9IFtdLFxuICAgICAgc2lua3NSaWdodCA9IHRydWU7XG5cbiAgc2Fua2V5Lm5vZGVXaWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlV2lkdGg7XG4gICAgbm9kZVdpZHRoID0gK187XG4gICAgcmV0dXJuIHNhbmtleTtcbiAgfTtcblxuICBzYW5rZXkubm9kZVBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVBhZGRpbmc7XG4gICAgbm9kZVBhZGRpbmcgPSArXztcbiAgICByZXR1cm4gc2Fua2V5O1xuICB9O1xuXG4gIHNhbmtleS5ub2RlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlcztcbiAgICBub2RlcyA9IF87XG4gICAgcmV0dXJuIHNhbmtleTtcbiAgfTtcblxuICBzYW5rZXkubGlua3MgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua3M7XG4gICAgbGlua3MgPSBfO1xuICAgIHJldHVybiBzYW5rZXk7XG4gIH07XG5cbiAgc2Fua2V5LnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICBzaXplID0gXztcbiAgICByZXR1cm4gc2Fua2V5O1xuICB9O1xuXG4gc2Fua2V5LnNpbmtzUmlnaHQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpbmtzUmlnaHQ7XG4gICAgc2lua3NSaWdodCA9IF87XG4gICAgcmV0dXJuIHNhbmtleTtcbiB9O1xuXG4gIHNhbmtleS5sYXlvdXQgPSBmdW5jdGlvbihpdGVyYXRpb25zKSB7XG4gICAgY29tcHV0ZU5vZGVMaW5rcygpO1xuICAgIGNvbXB1dGVOb2RlVmFsdWVzKCk7XG4gICAgY29tcHV0ZU5vZGVCcmVhZHRocygpO1xuICAgIGNvbXB1dGVOb2RlRGVwdGhzKGl0ZXJhdGlvbnMpO1xuICAgIHJldHVybiBzYW5rZXk7XG4gIH07XG5cbiAgc2Fua2V5LnJlbGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgY29tcHV0ZUxpbmtEZXB0aHMoKTtcbiAgICByZXR1cm4gc2Fua2V5O1xuICB9O1xuXG4gIC8vIFNWRyBwYXRoIGRhdGEgZ2VuZXJhdG9yLCB0byBiZSB1c2VkIGFzIFwiZFwiIGF0dHJpYnV0ZSBvbiBcInBhdGhcIiBlbGVtZW50IHNlbGVjdGlvbi5cbiAgc2Fua2V5LmxpbmsgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VydmF0dXJlID0gLjU7XG5cbiAgICBmdW5jdGlvbiBsaW5rKGQpIHtcbiAgICAgIHZhciB4cyA9IGQuc291cmNlLnggKyBkLnNvdXJjZS5keCxcbiAgICAgICAgICB4dCA9IGQudGFyZ2V0LngsXG4gICAgICAgICAgeGkgPSBkMy5pbnRlcnBvbGF0ZU51bWJlcih4cywgeHQpLFxuICAgICAgICAgIHhzYyA9IHhpKGN1cnZhdHVyZSksXG4gICAgICAgICAgeHRjID0geGkoMSAtIGN1cnZhdHVyZSksXG4gICAgICAgICAgeXMgPSBkLnNvdXJjZS55ICsgZC5zeSArIGQuZHkgLyAyLFxuICAgICAgICAgIHl0ID0gZC50YXJnZXQueSArIGQudHkgKyBkLmR5IC8gMjtcblxuICAgICAgaWYgKCFkLmN5Y2xlQnJlYWtlcikge1xuICAgICAgICByZXR1cm4gXCJNXCIgKyB4cyArIFwiLFwiICsgeXNcbiAgICAgICAgICAgICArIFwiQ1wiICsgeHNjICsgXCIsXCIgKyB5c1xuICAgICAgICAgICAgICsgXCIgXCIgKyB4dGMgKyBcIixcIiArIHl0XG4gICAgICAgICAgICAgKyBcIiBcIiArIHh0ICsgXCIsXCIgKyB5dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ZGVsdGEgPSAoMS41ICogZC5keSArIDAuMDUgKiBNYXRoLmFicyh4cyAtIHh0KSk7XG4gICAgICAgIHhzYyA9IHhzICsgeGRlbHRhO1xuICAgICAgICB4dGMgPSB4dCAtIHhkZWx0YTtcbiAgICAgICAgdmFyIHhtID0geGkoMC41KTtcbiAgICAgICAgdmFyIHltID0gZDMuaW50ZXJwb2xhdGVOdW1iZXIoeXMsIHl0KSgwLjUpO1xuICAgICAgICB2YXIgeWRlbHRhID0gKDIgKiBkLmR5ICsgMC4xICogTWF0aC5hYnMoeHMgLSB4dCkgKyAwLjEgKiBNYXRoLmFicyh5cyAtIHl0KSkgKiAoeW0gPCAoc2l6ZVsxXSAvIDIpID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIFwiTVwiICsgeHMgKyBcIixcIiArIHlzXG4gICAgICAgICAgICAgKyBcIkNcIiArIHhzYyArIFwiLFwiICsgeXNcbiAgICAgICAgICAgICArIFwiIFwiICsgeHNjICsgXCIsXCIgKyAoeXMgKyB5ZGVsdGEpXG4gICAgICAgICAgICAgKyBcIiBcIiArIHhtICsgXCIsXCIgKyAoeW0gKyB5ZGVsdGEpXG4gICAgICAgICAgICAgKyBcIlNcIiArIHh0YyArIFwiLFwiICsgeXRcbiAgICAgICAgICAgICArIFwiIFwiICsgeHQgKyBcIixcIiArIHl0O1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGluay5jdXJ2YXR1cmUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjdXJ2YXR1cmU7XG4gICAgICBjdXJ2YXR1cmUgPSArXztcbiAgICAgIHJldHVybiBsaW5rO1xuICAgIH07XG5cbiAgICByZXR1cm4gbGluaztcbiAgfTtcblxuICAvLyBQb3B1bGF0ZSB0aGUgc291cmNlTGlua3MgYW5kIHRhcmdldExpbmtzIGZvciBlYWNoIG5vZGUuXG4gIC8vIEFsc28sIGlmIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBhcmUgbm90IG9iamVjdHMsIGFzc3VtZSB0aGV5IGFyZSBpbmRpY2VzLlxuICBmdW5jdGlvbiBjb21wdXRlTm9kZUxpbmtzKCkge1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgLy8gTGlua3MgdGhhdCBoYXZlIHRoaXMgbm9kZSBhcyBzb3VyY2UuXG4gICAgICBub2RlLnNvdXJjZUxpbmtzID0gW107XG4gICAgICAvLyBMaW5rcyB0aGF0IGhhdmUgdGhpcyBub2RlIGFzIHRhcmdldC5cbiAgICAgIG5vZGUudGFyZ2V0TGlua3MgPSBbXTtcbiAgICB9KTtcbiAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBsaW5rLnNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQgPSBsaW5rLnRhcmdldDtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm51bWJlclwiKSBzb3VyY2UgPSBsaW5rLnNvdXJjZSA9IG5vZGVzW2xpbmsuc291cmNlXTtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcIm51bWJlclwiKSB0YXJnZXQgPSBsaW5rLnRhcmdldCA9IG5vZGVzW2xpbmsudGFyZ2V0XTtcbiAgICAgIHNvdXJjZS5zb3VyY2VMaW5rcy5wdXNoKGxpbmspO1xuICAgICAgdGFyZ2V0LnRhcmdldExpbmtzLnB1c2gobGluayk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSB2YWx1ZSAoc2l6ZSkgb2YgZWFjaCBub2RlIGJ5IHN1bW1pbmcgdGhlIGFzc29jaWF0ZWQgbGlua3MuXG4gIGZ1bmN0aW9uIGNvbXB1dGVOb2RlVmFsdWVzKCkge1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IE1hdGgubWF4KFxuICAgICAgICBkMy5zdW0obm9kZS5zb3VyY2VMaW5rcywgdmFsdWUpLFxuICAgICAgICBkMy5zdW0obm9kZS50YXJnZXRMaW5rcywgdmFsdWUpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gSXRlcmF0aXZlbHkgYXNzaWduIHRoZSBicmVhZHRoICh4LXBvc2l0aW9uKSBmb3IgZWFjaCBub2RlLlxuICAvLyBOb2RlcyBhcmUgYXNzaWduZWQgdGhlIG1heGltdW0gYnJlYWR0aCBvZiBpbmNvbWluZyBuZWlnaGJvcnMgcGx1cyBvbmU7XG4gIC8vIG5vZGVzIHdpdGggbm8gaW5jb21pbmcgbGlua3MgYXJlIGFzc2lnbmVkIGJyZWFkdGggemVybywgd2hpbGVcbiAgLy8gbm9kZXMgd2l0aCBubyBvdXRnb2luZyBsaW5rcyBhcmUgYXNzaWduZWQgdGhlIG1heGltdW0gYnJlYWR0aC5cbiAgZnVuY3Rpb24gY29tcHV0ZU5vZGVCcmVhZHRocygpIHtcbiAgICB2YXIgcmVtYWluaW5nTm9kZXMgPSBub2RlcyxcbiAgICAgICAgbmV4dE5vZGVzLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgY2FudGlkYWRDb2wgPSA0O1xuXG4gICAgLy8gV29yayBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgLy8gS2VlcCB1cGRhdGluZyB0aGUgYnJlYXRoICh4LXBvc2l0aW9uKSBvZiBub2RlcyB0aGF0IGFyZSB0YXJnZXQgb2YgcmVjZW50bHkgdXBkYXRlZCBub2Rlcy5cblxuICAgIHdoaWxlIChyZW1haW5pbmdOb2Rlcy5sZW5ndGggJiYgeCA8IG5vZGVzLmxlbmd0aCkge1xuICAgICAgbmV4dE5vZGVzID0gW107XG5cbiAgICAgIHJlbWFpbmluZ05vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLnggPSBub2RlLnBvcyAtIDE7XG4gICAgICAgIG5vZGUuZHggPSBub2RlV2lkdGg7XG5cbiAgICAgICAgbm9kZS5zb3VyY2VMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICBpZiAobmV4dE5vZGVzLmluZGV4T2YobGluay50YXJnZXQpIDwgMCAmJiAhbGluay5jeWNsZUJyZWFrZXIpIHtcbiAgICAgICAgICAgIG5leHROb2Rlcy5wdXNoKGxpbmsudGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZXh0Tm9kZXMubGVuZ3RoID09IHJlbWFpbmluZ05vZGVzLmxlbmd0aCkge1xuICAgICAgICAvLyBUaGVyZSBtdXN0IGJlIGEgY3ljbGUgaGVyZS4gTGV0J3Mgc2VhcmNoIGZvciBhIGxpbmsgdGhhdCBicmVha3MgaXQuXG4gICAgICAgIGZpbmRBbmRNYXJrQ3ljbGVCcmVha2VyKG5leHROb2Rlcyk7XG4gICAgICAgIC8vIFN0YXJ0IG92ZXIuXG4gICAgICAgIC8vIFRPRE86IG1ha2UgdGhpcyBvcHRpb25hbD9cbiAgICAgICAgcmV0dXJuIGNvbXB1dGVOb2RlQnJlYWR0aHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbWFpbmluZ05vZGVzID0gbmV4dE5vZGVzO1xuICAgICAgICArK3g7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE9wdGlvbmFsbHkgbW92ZSBwdXJlIHNpbmtzIGFsd2F5cyB0byB0aGUgcmlnaHQuXG4gICAgLy8gaWYgKHNpbmtzUmlnaHQpIHtcbiAgICAvLyAgIG1vdmVTaW5rc1JpZ2h0KGNhbnRpZGFkQ29sKTtcbiAgICAvLyB9XG4gICAgLy8gc2NhbGVOb2RlQnJlYWR0aHMoKHNpemVbMF0gLSBub2RlV2lkdGgpIC8gKHggLSA1KSk7XG4gICAgc2NhbGVOb2RlQnJlYWR0aHMoKHNpemVbMF0gLSBub2RlV2lkdGgpIC8gKGNhbnRpZGFkQ29sIC0gMSkpO1xuICB9XG5cbiAgLy8gRmluZCBhIGxpbmsgdGhhdCBicmVha3MgYSBjeWNsZSBpbiB0aGUgZ3JhcGggKGlmIGFueSkuXG4gIGZ1bmN0aW9uIGZpbmRBbmRNYXJrQ3ljbGVCcmVha2VyKG5vZGVzKSB7XG4gIC8vIEdvIHRocm91Z2ggYWxsIG5vZGVzIGZyb20gdGhlIGdpdmVuIHN1YnNldCBhbmQgdHJhdmVyc2UgbGlua3Mgc2VhcmNoaW5nIGZvciBjeWNsZXMuXG4gICAgdmFyIGxpbms7XG4gICAgZm9yICh2YXIgbj1ub2Rlcy5sZW5ndGggLSAxOyBuID49IDA7IG4tLSkge1xuICAgICAgbGluayA9IGRlcHRoRmlyc3RDeWNsZVNlYXJjaChub2Rlc1tuXSwgW10pO1xuICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVwdGgtZmlyc3Qgc2VhcmNoIHRvIGZpbmQgYSBsaW5rIHRoYXQgaXMgcGFydCBvZiBhIGN5Y2xlLlxuICAgIGZ1bmN0aW9uIGRlcHRoRmlyc3RDeWNsZVNlYXJjaChjdXJzb3JOb2RlLCBwYXRoKSB7XG4gICAgICB2YXIgdGFyZ2V0LCBsaW5rO1xuICAgICAgZm9yICh2YXIgbiA9IGN1cnNvck5vZGUuc291cmNlTGlua3MubGVuZ3RoIC0gMTsgbiA+PSAwOyBuLS0pIHtcbiAgICAgICAgbGluayA9IGN1cnNvck5vZGUuc291cmNlTGlua3Nbbl07XG4gICAgICAgIGlmIChsaW5rLmN5Y2xlQnJlYWtlcikge1xuICAgICAgICAgIC8vIFNraXAgYWxyZWFkeSBrbm93biBjeWNsZSBicmVha2Vycy5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBvZiBsaW5rIG1ha2VzIGEgY3ljbGUgaW4gY3VycmVudCBwYXRoLlxuICAgICAgICB0YXJnZXQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBwYXRoLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgaWYgKHBhdGhbbF0uc291cmNlID09IHRhcmdldCkge1xuICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBjeWNsZS4gU2VhcmNoIGZvciB3ZWFrZXN0IGxpbmsgaW4gY3ljbGVcbiAgICAgICAgICAgIHZhciB3ZWFrZXN0ID0gbGluaztcbiAgICAgICAgICAgIGZvciAoOyBsIDwgcGF0aC5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICBpZiAocGF0aFtsXS52YWx1ZSA8IHdlYWtlc3QudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB3ZWFrZXN0ID0gcGF0aFtsXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFyayB3ZWFrZXN0IGxpbmsgYXMgKGtub3duKSBjeWNsZSBicmVha2VyIGFuZCBhYm9ydCBzZWFyY2guXG4gICAgICAgICAgICB3ZWFrZXN0LmN5Y2xlQnJlYWtlciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gd2Vha2VzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWN1cnNlIGRlZXBlci5cbiAgICAgICAgcGF0aC5wdXNoKGxpbmspO1xuICAgICAgICBsaW5rID0gZGVwdGhGaXJzdEN5Y2xlU2VhcmNoKHRhcmdldCwgcGF0aCk7XG4gICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgIC8vIFN0b3AgZnVydGhlciBzZWFyY2ggaWYgd2UgZm91bmQgYSBjeWNsZSBicmVha2VyLlxuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgIHJldHVybiBsaW5rO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBtb3ZlU291cmNlc1JpZ2h0KCkge1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKCFub2RlLnRhcmdldExpbmtzLmxlbmd0aCkge1xuICAgICAgICBub2RlLnggPSBkMy5taW4obm9kZS5zb3VyY2VMaW5rcywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50YXJnZXQueDsgfSkgLSAxO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbW92ZVNpbmtzUmlnaHQoeCkge1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKCFub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCkge1xuICAgICAgICBub2RlLnggPSB4IC0gMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlTm9kZUJyZWFkdGhzKGt4KSB7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnggKj0ga3g7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBkZXB0aCAoeS1wb3NpdGlvbikgZm9yIGVhY2ggbm9kZS5cbiAgZnVuY3Rpb24gY29tcHV0ZU5vZGVEZXB0aHMoaXRlcmF0aW9ucykge1xuICAgIC8vIEdyb3VwIG5vZGVzIGJ5IGJyZWF0aC5cbiAgICB2YXIgbm9kZXNCeUJyZWFkdGggPSBkMy5uZXN0KClcbiAgICAgICAgLmtleShmdW5jdGlvbihkKSB7IHJldHVybiBkLng7IH0pXG4gICAgICAgIC5zb3J0S2V5cyhkMy5hc2NlbmRpbmcpXG4gICAgICAgIC5lbnRyaWVzKG5vZGVzKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzOyB9KTtcblxuICAgIC8vXG4gICAgaW5pdGlhbGl6ZU5vZGVEZXB0aCgpO1xuICAgIHJlc29sdmVDb2xsaXNpb25zKCk7XG4gICAgY29tcHV0ZUxpbmtEZXB0aHMoKTtcbiAgICBmb3IgKHZhciBhbHBoYSA9IDE7IGl0ZXJhdGlvbnMgPiAwOyAtLWl0ZXJhdGlvbnMpIHtcbiAgICAgIHJlbGF4UmlnaHRUb0xlZnQoYWxwaGEgKj0gLjk5KTtcbiAgICAgIHJlc29sdmVDb2xsaXNpb25zKCk7XG4gICAgICBjb21wdXRlTGlua0RlcHRocygpO1xuICAgICAgcmVsYXhMZWZ0VG9SaWdodChhbHBoYSk7XG4gICAgICByZXNvbHZlQ29sbGlzaW9ucygpO1xuICAgICAgY29tcHV0ZUxpbmtEZXB0aHMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplTm9kZURlcHRoKCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHZlcnRpY2FsIHNjYWxpbmcgZmFjdG9yLlxuICAgICAgdmFyIGt5ID0gZDMubWluKG5vZGVzQnlCcmVhZHRoLCBmdW5jdGlvbihub2Rlcykge1xuICAgICAgICByZXR1cm4gKHNpemVbMV0gLSAobm9kZXMubGVuZ3RoIC0gMSkgKiBub2RlUGFkZGluZykgLyBkMy5zdW0obm9kZXMsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBub2Rlc0J5QnJlYWR0aC5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSwgaSkge1xuICAgICAgICAgIG5vZGUueSA9IGk7XG4gICAgICAgICAgbm9kZS5keSA9IG5vZGUudmFsdWUgKiBreTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgIGxpbmsuZHkgPSBsaW5rLnZhbHVlICoga3k7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxheExlZnRUb1JpZ2h0KGFscGhhKSB7XG4gICAgICBub2Rlc0J5QnJlYWR0aC5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVzLCBicmVhZHRoKSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLnRhcmdldExpbmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVmFsdWUtd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgeS1wb3NpdGlvbiBvZiBzb3VyY2Ugbm9kZSBjZW50ZXJzIGxpbmtlZCB0byB0aGlzIG5vZGUuXG4gICAgICAgICAgICB2YXIgeSA9IGQzLnN1bShub2RlLnRhcmdldExpbmtzLCB3ZWlnaHRlZFNvdXJjZSkgLyBkMy5zdW0obm9kZS50YXJnZXRMaW5rcywgdmFsdWUpO1xuICAgICAgICAgICAgbm9kZS55ICs9ICh5IC0gY2VudGVyKG5vZGUpKSAqIGFscGhhO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gd2VpZ2h0ZWRTb3VyY2UobGluaykge1xuICAgICAgICByZXR1cm4gKGxpbmsuc291cmNlLnkgKyBsaW5rLnN5ICsgbGluay5keSAvIDIpICogbGluay52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxheFJpZ2h0VG9MZWZ0KGFscGhhKSB7XG4gICAgICBub2Rlc0J5QnJlYWR0aC5zbGljZSgpLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVmFsdWUtd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgeS1wb3NpdGlvbnMgb2YgdGFyZ2V0IG5vZGVzIGxpbmtlZCB0byB0aGlzIG5vZGUuXG4gICAgICAgICAgICB2YXIgeSA9IGQzLnN1bShub2RlLnNvdXJjZUxpbmtzLCB3ZWlnaHRlZFRhcmdldCkgLyBkMy5zdW0obm9kZS5zb3VyY2VMaW5rcywgdmFsdWUpO1xuICAgICAgICAgICAgbm9kZS55ICs9ICh5IC0gY2VudGVyKG5vZGUpKSAqIGFscGhhO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gd2VpZ2h0ZWRUYXJnZXQobGluaykge1xuICAgICAgICByZXR1cm4gKGxpbmsudGFyZ2V0LnkgKyBsaW5rLnR5ICsgbGluay5keSAvIDIpICogbGluay52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlQ29sbGlzaW9ucygpIHtcbiAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgdmFyIG5vZGUsXG4gICAgICAgICAgICBkeSxcbiAgICAgICAgICAgIHkwID0gMCxcbiAgICAgICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIFB1c2ggYW55IG92ZXJsYXBwaW5nIG5vZGVzIGRvd24uXG4gICAgICAgIG5vZGVzLnNvcnQoYnlWYWx1ZSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgZHkgPSB5MCAtIG5vZGUueTtcbiAgICAgICAgICBpZiAoZHkgPiAwKSBub2RlLnkgKz0gZHk7XG4gICAgICAgICAgeTAgPSBub2RlLnkgKyBub2RlLmR5ICsgbm9kZVBhZGRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgYm90dG9tbW9zdCBub2RlIGdvZXMgb3V0c2lkZSB0aGUgYm91bmRzLCBwdXNoIGl0IGJhY2sgdXAuXG4gICAgICAgIGR5ID0geTAgLSBub2RlUGFkZGluZyAtIHNpemVbMV07XG4gICAgICAgIGlmIChkeSA+IDApIHtcbiAgICAgICAgICB5MCA9IG5vZGUueSAtPSBkeTtcblxuICAgICAgICAgIC8vIFB1c2ggYW55IG92ZXJsYXBwaW5nIG5vZGVzIGJhY2sgdXAuXG4gICAgICAgICAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBkeSA9IG5vZGUueSArIG5vZGUuZHkgKyBub2RlUGFkZGluZyAtIHkwO1xuICAgICAgICAgICAgaWYgKGR5ID4gMCkgbm9kZS55IC09IGR5O1xuICAgICAgICAgICAgeTAgPSBub2RlLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc2NlbmRpbmdEZXB0aChhLCBiKSB7XG4gICAgICByZXR1cm4gYS55IC0gYi55O1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgeS1vZmZzZXQgb2YgdGhlIHNvdXJjZSBlbmRwb2ludCAoc3kpIGFuZCB0YXJnZXQgZW5kcG9pbnRzICh0eSkgb2YgbGlua3MsXG4gIC8vIHJlbGF0aXZlIHRvIHRoZSBzb3VyY2UvdGFyZ2V0IG5vZGUncyB5LXBvc2l0aW9uLlxuICBmdW5jdGlvbiBjb21wdXRlTGlua0RlcHRocygpIHtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUuc291cmNlTGlua3Muc29ydChieVZhbHVlKTtcbiAgICAgIG5vZGUudGFyZ2V0TGlua3Muc29ydChieVZhbHVlKTtcbiAgICB9KTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBzeSA9IDAsIHR5ID0gMDtcbiAgICAgIG5vZGUuc291cmNlTGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgIGxpbmsuc3kgPSBzeTtcbiAgICAgICAgc3kgKz0gbGluay5keTtcbiAgICAgIH0pO1xuICAgICAgbm9kZS50YXJnZXRMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgbGluay50eSA9IHR5O1xuICAgICAgICB0eSArPSBsaW5rLmR5O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhc2NlbmRpbmdTb3VyY2VEZXB0aChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5zb3VyY2UueSAtIGIuc291cmNlLnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNjZW5kaW5nVGFyZ2V0RGVwdGgoYSwgYikge1xuICAgICAgcmV0dXJuIGEudGFyZ2V0LnkgLSBiLnRhcmdldC55O1xuICAgIH1cbiAgfVxuXG4gIC8vIFktcG9zaXRpb24gb2YgdGhlIG1pZGRsZSBvZiBhIG5vZGUuXG4gIGZ1bmN0aW9uIGNlbnRlcihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUueSArIG5vZGUuZHkgLyAyO1xuICB9XG5cbiAgLy8gVmFsdWUgcHJvcGVydHkgYWNjZXNzb3IuXG4gIGZ1bmN0aW9uIHZhbHVlKHgpIHtcbiAgICByZXR1cm4geC52YWx1ZTtcbiAgfVxuXG4gIC8vIEFsdGVyYWNpw7NuIGRlbCBjw7NkaWdvXG4gIC8vIE9yZGVuYSBsb3Mgbm9kb3MgZGUgbWF5b3IgYSBtZW5vciBlbiBmdW5jacOzbiBkZSBzdSB2YWxvclxuICBmdW5jdGlvbiBieVZhbHVlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBsZXQgZmlyc3RWYWx1ZSA9IGZpcnN0LnZhbHVlLFxuICAgICAgICBzZWNvbmRWYWx1ZSA9IHNlY29uZC52YWx1ZTtcblxuICAgIGlmIChmaXJzdFZhbHVlIDwgc2Vjb25kVmFsdWUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZmlyc3RWYWx1ZSA+IHNlY29uZFZhbHVlKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc2Fua2V5O1xufTtcbiJdfQ==
