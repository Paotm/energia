"use strict";

d3.sankey = function () {
  var sankey = {},
      nodeWidth = 24,
      nodePadding = 8,
      // was 8, needs to be much bigger. these numbers are actually overwritten in the html when we instantiate the viz!
  size = [1, 1],
      nodes = [],
      links = [];
  sankey.nodeWidth = function (_) {
    if (!arguments.length) return nodeWidth;
    nodeWidth = +_;
    return sankey;
  };
  sankey.nodePadding = function (_) {
    if (!arguments.length) return nodePadding;
    nodePadding = +_;
    return sankey;
  };
  sankey.nodes = function (_) {
    if (!arguments.length) return nodes;
    nodes = _;
    return sankey;
  };
  sankey.links = function (_) {
    if (!arguments.length) return links;
    links = _;
    return sankey;
  };
  sankey.size = function (_) {
    if (!arguments.length) return size;
    size = _;
    return sankey;
  };
  sankey.layout = function (iterations) {
    computeNodeLinks();
    computeNodeValues();

    // big changes here
    // change the order and depths (y pos) won't need iterations
    computeNodeDepths();
    computeNodeBreadths(iterations);

    computeLinkDepths();
    return sankey;
  };
  sankey.relayout = function () {
    computeLinkDepths();
    return sankey;
  };
  sankey.link = function () {
    var curvature = .5;

    // x0 = line start X
    // y0 = line start Y

    // x1 = line end X
    // y1 = line end Y

    // y2 = control point 1 (Y pos)
    // y3 = control point 2 (Y pos)

    function link(d) {

      // big changes here obviously, more comments to follow
      var x0 = d.source.x + d.sy + d.dy / 2,
          x1 = d.target.x + d.ty + d.dy / 2,
          y0 = d.source.y + nodeWidth,
          y1 = d.target.y,
          yi = d3.interpolateNumber(y0, y1),
          y2 = yi(curvature),
          y3 = yi(1 - curvature);

      // ToDo - nice to have - allow flow up or down! Plenty of use cases for starting at the bottom,
      // but main one is trickle down (economics, budgets etc), not up

      return "M" + x0 + "," + y0 // start (of SVG path)
      + "C" + x0 + "," + y2 // CP1 (curve control point)
      + " " + x1 + "," + y3 // CP2
      + " " + x1 + "," + y1; // end
    }

    link.curvature = function (_) {
      if (!arguments.length) return curvature;
      curvature = +_;
      return link;
    };

    return link;
  };

  // Populate the sourceLinks and targetLinks for each node.
  // Also, if the source and target are not objects, assume they are indices.
  function computeNodeLinks() {
    nodes.forEach(function (node) {
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    links.forEach(function (link) {
      var source = link.source,
          target = link.target;
      if (typeof source === "number") source = link.source = nodes[link.source];
      if (typeof target === "number") target = link.target = nodes[link.target];
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
  }

  // Compute the value (size) of each node by summing the associated links.
  function computeNodeValues() {
    nodes.forEach(function (node) {
      node.value = Math.max(d3.sum(node.sourceLinks, value), d3.sum(node.targetLinks, value));
    });
  }

  // take a grouping of the nodes - the vertical columns
  // there shouldnt be 8 - there will be more, the total number of 1st level sources
  // then iterate over them and give them an incrementing x
  // because the data structure is ALL nodes, just flattened, don't just apply at the top level
  // then everything should have an X
  // THEN, for the Y
  // do the same thing, this time on the grouping of 8! i.e. 8 different Y values, not loads of different ones!
  function computeNodeBreadths(iterations) {
    var nodesByBreadth = d3.nest().key(function (d) {
      return d.y;
    }).sortKeys(d3.ascending).entries(nodes).map(function (d) {
      return d.values;
    }); // values! we are using the values also as a way to seperate nodes (not just stroke width)?

    // this bit is actually the node sizes (widths)
    //var ky = (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value)
    // this should be only source nodes surely (level 1)
    var ky = (size[0] - (nodesByBreadth[0].length - 1) * nodePadding) / d3.sum(nodesByBreadth[0], value);
    // I'd like them to be much bigger, this calc doesn't seem to fill the space!?

    nodesByBreadth.forEach(function (nodes) {
      nodes.forEach(function (node, i) {
        node.x = i;
        node.dy = node.value * ky;
      });
    });

    links.forEach(function (link) {
      link.dy = link.value * ky;
    });

    resolveCollisions();

    for (var alpha = 1; iterations > 0; --iterations) {
      relaxLeftToRight(alpha);
      resolveCollisions();

      relaxRightToLeft(alpha *= .99);
      resolveCollisions();
    }

    // these relax methods should probably be operating on one level of the nodes, not all!?

    function relaxLeftToRight(alpha) {
      nodesByBreadth.forEach(function (nodes, breadth) {
        nodes.forEach(function (node) {
          if (node.targetLinks.length) {
            var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
            node.x += (y - center(node)) * alpha;
          }
        });
      });

      function weightedSource(link) {
        return center(link.source) * link.value;
      }
    }

    function relaxRightToLeft(alpha) {
      nodesByBreadth.slice().reverse().forEach(function (nodes) {
        nodes.forEach(function (node) {
          if (node.sourceLinks.length) {
            var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
            node.x += (y - center(node)) * alpha;
          }
        });
      });

      function weightedTarget(link) {
        return center(link.target) * link.value;
      }
    }

    function resolveCollisions() {
      nodesByBreadth.forEach(function (nodes) {
        var node,
            dy,
            x0 = 0,
            n = nodes.length,
            i;

        // Push any overlapping nodes right.
        nodes.sort(ascendingDepth);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dy = x0 - node.x;
          if (dy > 0) node.x += dy;
          x0 = node.x + node.dy + nodePadding;
        }

        // If the rightmost node goes outside the bounds, push it left.
        dy = x0 - nodePadding - size[0]; // was size[1]
        if (dy > 0) {
          x0 = node.x -= dy;

          // Push any overlapping nodes left.
          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.x + node.dy + nodePadding - x0; // was y0
            if (dy > 0) node.x -= dy;
            x0 = node.x;
          }
        }
      });
    }

    function ascendingDepth(a, b) {
      return a.x - b.x; // left sort
      // return b.x - a.x; // right sort
    }
  }

  // this moves all end points (sinks!) to the most extreme bottom
  function moveSinksDown(y) {
    nodes.forEach(function (node) {
      if (!node.sourceLinks.length) {
        node.y = y - 1;
      }
    });
  }

  // shift their locations out to occupy the screen
  function scaleNodeBreadths(kx) {
    nodes.forEach(function (node) {
      node.y *= kx;
    });
  }

  function computeNodeDepths() {
    var remainingNodes = nodes,
        nextNodes,
        y = 0;

    while (remainingNodes.length) {
      nextNodes = [];
      remainingNodes.forEach(function (node) {
        node.y = y;
        //node.dx = nodeWidth;
        node.sourceLinks.forEach(function (link) {
          if (nextNodes.indexOf(link.target) < 0) {
            nextNodes.push(link.target);
          }
        });
      });
      remainingNodes = nextNodes;
      ++y;
    }

    // move end points to the very bottom
    moveSinksDown(y);

    scaleNodeBreadths((size[1] - nodeWidth) / (y - 1));
  }

  // .ty is the offset in terms of node position of the link (target)
  function computeLinkDepths() {
    nodes.forEach(function (node) {
      node.sourceLinks.sort(ascendingTargetDepth);
      node.targetLinks.sort(ascendingSourceDepth);
    });
    nodes.forEach(function (node) {
      var sy = 0,
          ty = 0;
      //ty = node.dy;
      node.sourceLinks.forEach(function (link) {
        link.sy = sy;
        sy += link.dy;
      });
      node.targetLinks.forEach(function (link) {
        // this is simply saying, for each target, keep adding the width of the link
        // so what if it was the other way round. start with full width then subtract?
        link.ty = ty;
        ty += link.dy;
        //ty -= link.dy;
      });
    });

    function ascendingSourceDepth(a, b) {
      // return a.source.y - b.source.y;
      return a.source.x - b.source.x;
    }

    function ascendingTargetDepth(a, b) {
      //return a.target.y - b.target.y;
      return a.target.x - b.target.x;
    }
  }

  function center(node) {
    return 0; // AlteraciÃ³n del codigo
    // return node.y + node.dy / 2;
  }

  function value(link) {
    return link.value;
  }

  return sankey;
};
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQzLXZlcnRpY2FsU2Fua2V5LmpzIl0sIm5hbWVzIjpbImQzIiwic2Fua2V5Iiwibm9kZVdpZHRoIiwibm9kZVBhZGRpbmciLCJzaXplIiwibm9kZXMiLCJsaW5rcyIsIl8iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJsYXlvdXQiLCJpdGVyYXRpb25zIiwiY29tcHV0ZU5vZGVMaW5rcyIsImNvbXB1dGVOb2RlVmFsdWVzIiwiY29tcHV0ZU5vZGVEZXB0aHMiLCJjb21wdXRlTm9kZUJyZWFkdGhzIiwiY29tcHV0ZUxpbmtEZXB0aHMiLCJyZWxheW91dCIsImxpbmsiLCJjdXJ2YXR1cmUiLCJkIiwieDAiLCJzb3VyY2UiLCJ4Iiwic3kiLCJkeSIsIngxIiwidGFyZ2V0IiwidHkiLCJ5MCIsInkiLCJ5MSIsInlpIiwiaW50ZXJwb2xhdGVOdW1iZXIiLCJ5MiIsInkzIiwiZm9yRWFjaCIsIm5vZGUiLCJzb3VyY2VMaW5rcyIsInRhcmdldExpbmtzIiwicHVzaCIsInZhbHVlIiwiTWF0aCIsIm1heCIsInN1bSIsIm5vZGVzQnlCcmVhZHRoIiwibmVzdCIsImtleSIsInNvcnRLZXlzIiwiYXNjZW5kaW5nIiwiZW50cmllcyIsIm1hcCIsInZhbHVlcyIsImt5IiwiaSIsInJlc29sdmVDb2xsaXNpb25zIiwiYWxwaGEiLCJyZWxheExlZnRUb1JpZ2h0IiwicmVsYXhSaWdodFRvTGVmdCIsImJyZWFkdGgiLCJ3ZWlnaHRlZFNvdXJjZSIsImNlbnRlciIsInNsaWNlIiwicmV2ZXJzZSIsIndlaWdodGVkVGFyZ2V0IiwibiIsInNvcnQiLCJhc2NlbmRpbmdEZXB0aCIsImEiLCJiIiwibW92ZVNpbmtzRG93biIsInNjYWxlTm9kZUJyZWFkdGhzIiwia3giLCJyZW1haW5pbmdOb2RlcyIsIm5leHROb2RlcyIsImluZGV4T2YiLCJhc2NlbmRpbmdUYXJnZXREZXB0aCIsImFzY2VuZGluZ1NvdXJjZURlcHRoIl0sIm1hcHBpbmdzIjoiOztBQUFBQSxHQUFHQyxNQUFILEdBQVks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Q0FBU0osQ0FBN0I7QUFDSDtBQUNGOztBQUVELFdBQVNzQyxNQUFULENBQWdCeEIsSUFBaEIsRUFBc0I7QUFDcEIsV0FBTyxDQUFQLENBRG9CLENBQ1Y7QUFDVjtBQUNEOztBQUVELFdBQVNJLEtBQVQsQ0FBZXZCLElBQWYsRUFBcUI7QUFDbkIsV0FBT0EsS0FBS3VCLEtBQVo7QUFDRDs7QUFFRCxTQUFPeEMsTUFBUDtBQUNELENBelREIiwiZmlsZSI6ImQzLXZlcnRpY2FsU2Fua2V5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZDMuc2Fua2V5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzYW5rZXkgPSB7fSxcbiAgICAgIG5vZGVXaWR0aCA9IDI0LFxuICAgICAgbm9kZVBhZGRpbmcgPSA4LCAvLyB3YXMgOCwgbmVlZHMgdG8gYmUgbXVjaCBiaWdnZXIuIHRoZXNlIG51bWJlcnMgYXJlIGFjdHVhbGx5IG92ZXJ3cml0dGVuIGluIHRoZSBodG1sIHdoZW4gd2UgaW5zdGFudGlhdGUgdGhlIHZpeiFcbiAgICAgIHNpemUgPSBbMSwgMV0sXG4gICAgICBub2RlcyA9IFtdLFxuICAgICAgbGlua3MgPSBbXTtcbiAgc2Fua2V5Lm5vZGVXaWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlV2lkdGg7XG4gICAgbm9kZVdpZHRoID0gK187XG4gICAgcmV0dXJuIHNhbmtleTtcbiAgfTtcbiAgc2Fua2V5Lm5vZGVQYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVQYWRkaW5nO1xuICAgIG5vZGVQYWRkaW5nID0gK187XG4gICAgcmV0dXJuIHNhbmtleTtcbiAgfTtcbiAgc2Fua2V5Lm5vZGVzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVzO1xuICAgIG5vZGVzID0gXztcbiAgICByZXR1cm4gc2Fua2V5O1xuICB9O1xuICBzYW5rZXkubGlua3MgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua3M7XG4gICAgbGlua3MgPSBfO1xuICAgIHJldHVybiBzYW5rZXk7XG4gIH07XG4gIHNhbmtleS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgc2l6ZSA9IF87XG4gICAgcmV0dXJuIHNhbmtleTtcbiAgfTtcbiAgc2Fua2V5LmxheW91dCA9IGZ1bmN0aW9uKGl0ZXJhdGlvbnMpIHtcbiAgICBjb21wdXRlTm9kZUxpbmtzKCk7XG4gICAgY29tcHV0ZU5vZGVWYWx1ZXMoKTtcblxuICAgIC8vIGJpZyBjaGFuZ2VzIGhlcmVcbiAgICAvLyBjaGFuZ2UgdGhlIG9yZGVyIGFuZCBkZXB0aHMgKHkgcG9zKSB3b24ndCBuZWVkIGl0ZXJhdGlvbnNcbiAgICBjb21wdXRlTm9kZURlcHRocygpO1xuICAgIGNvbXB1dGVOb2RlQnJlYWR0aHMoaXRlcmF0aW9ucyk7XG5cbiAgICBjb21wdXRlTGlua0RlcHRocygpO1xuICAgIHJldHVybiBzYW5rZXk7XG4gIH07XG4gIHNhbmtleS5yZWxheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbXB1dGVMaW5rRGVwdGhzKCk7XG4gICAgcmV0dXJuIHNhbmtleTtcbiAgfTtcbiAgc2Fua2V5LmxpbmsgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VydmF0dXJlID0gLjU7XG5cbiAgICAgIC8vIHgwID0gbGluZSBzdGFydCBYXG4gICAgICAvLyB5MCA9IGxpbmUgc3RhcnQgWVxuXG4gICAgICAvLyB4MSA9IGxpbmUgZW5kIFhcbiAgICAgIC8vIHkxID0gbGluZSBlbmQgWVxuXG4gICAgICAvLyB5MiA9IGNvbnRyb2wgcG9pbnQgMSAoWSBwb3MpXG4gICAgICAvLyB5MyA9IGNvbnRyb2wgcG9pbnQgMiAoWSBwb3MpXG5cbiAgICBmdW5jdGlvbiBsaW5rKGQpIHtcblxuICAgICAgICAvLyBiaWcgY2hhbmdlcyBoZXJlIG9idmlvdXNseSwgbW9yZSBjb21tZW50cyB0byBmb2xsb3dcbiAgICAgICAgdmFyIHgwID0gZC5zb3VyY2UueCArIGQuc3kgKyBkLmR5IC8gMixcbiAgICAgICAgICAgIHgxID0gZC50YXJnZXQueCArIGQudHkgKyBkLmR5IC8gMixcbiAgICAgICAgICB5MCA9IGQuc291cmNlLnkgKyBub2RlV2lkdGgsXG4gICAgICAgICAgeTEgPSBkLnRhcmdldC55LFxuICAgICAgICAgIHlpID0gZDMuaW50ZXJwb2xhdGVOdW1iZXIoeTAsIHkxKSxcbiAgICAgICAgICB5MiA9IHlpKGN1cnZhdHVyZSksXG4gICAgICAgICAgeTMgPSB5aSgxIC0gY3VydmF0dXJlKTtcblxuICAgICAgICAvLyBUb0RvIC0gbmljZSB0byBoYXZlIC0gYWxsb3cgZmxvdyB1cCBvciBkb3duISBQbGVudHkgb2YgdXNlIGNhc2VzIGZvciBzdGFydGluZyBhdCB0aGUgYm90dG9tLFxuICAgICAgICAvLyBidXQgbWFpbiBvbmUgaXMgdHJpY2tsZSBkb3duIChlY29ub21pY3MsIGJ1ZGdldHMgZXRjKSwgbm90IHVwXG5cbiAgICAgIHJldHVybiBcIk1cIiArIHgwICsgXCIsXCIgKyB5MCAgICAgICAgLy8gc3RhcnQgKG9mIFNWRyBwYXRoKVxuICAgICAgICAgICArIFwiQ1wiICsgeDAgKyBcIixcIiArIHkyICAgICAgLy8gQ1AxIChjdXJ2ZSBjb250cm9sIHBvaW50KVxuICAgICAgICAgICArIFwiIFwiICsgeDEgKyBcIixcIiArIHkzICAgICAgLy8gQ1AyXG4gICAgICAgICAgICsgXCIgXCIgKyB4MSArIFwiLFwiICsgeTE7ICAgICAgIC8vIGVuZFxuICAgIH1cblxuICAgIGxpbmsuY3VydmF0dXJlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY3VydmF0dXJlO1xuICAgICAgY3VydmF0dXJlID0gK187XG4gICAgICByZXR1cm4gbGluaztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxpbms7XG4gIH07XG5cbiAgLy8gUG9wdWxhdGUgdGhlIHNvdXJjZUxpbmtzIGFuZCB0YXJnZXRMaW5rcyBmb3IgZWFjaCBub2RlLlxuICAvLyBBbHNvLCBpZiB0aGUgc291cmNlIGFuZCB0YXJnZXQgYXJlIG5vdCBvYmplY3RzLCBhc3N1bWUgdGhleSBhcmUgaW5kaWNlcy5cbiAgZnVuY3Rpb24gY29tcHV0ZU5vZGVMaW5rcygpIHtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUuc291cmNlTGlua3MgPSBbXTtcbiAgICAgIG5vZGUudGFyZ2V0TGlua3MgPSBbXTtcbiAgICB9KTtcbiAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBsaW5rLnNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQgPSBsaW5rLnRhcmdldDtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm51bWJlclwiKSBzb3VyY2UgPSBsaW5rLnNvdXJjZSA9IG5vZGVzW2xpbmsuc291cmNlXTtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcIm51bWJlclwiKSB0YXJnZXQgPSBsaW5rLnRhcmdldCA9IG5vZGVzW2xpbmsudGFyZ2V0XTtcbiAgICAgIHNvdXJjZS5zb3VyY2VMaW5rcy5wdXNoKGxpbmspO1xuICAgICAgdGFyZ2V0LnRhcmdldExpbmtzLnB1c2gobGluayk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSB2YWx1ZSAoc2l6ZSkgb2YgZWFjaCBub2RlIGJ5IHN1bW1pbmcgdGhlIGFzc29jaWF0ZWQgbGlua3MuXG4gIGZ1bmN0aW9uIGNvbXB1dGVOb2RlVmFsdWVzKCkge1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IE1hdGgubWF4KFxuICAgICAgICBkMy5zdW0obm9kZS5zb3VyY2VMaW5rcywgdmFsdWUpLFxuICAgICAgICBkMy5zdW0obm9kZS50YXJnZXRMaW5rcywgdmFsdWUpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdGFrZSBhIGdyb3VwaW5nIG9mIHRoZSBub2RlcyAtIHRoZSB2ZXJ0aWNhbCBjb2x1bW5zXG4gIC8vIHRoZXJlIHNob3VsZG50IGJlIDggLSB0aGVyZSB3aWxsIGJlIG1vcmUsIHRoZSB0b3RhbCBudW1iZXIgb2YgMXN0IGxldmVsIHNvdXJjZXNcbiAgLy8gdGhlbiBpdGVyYXRlIG92ZXIgdGhlbSBhbmQgZ2l2ZSB0aGVtIGFuIGluY3JlbWVudGluZyB4XG4gIC8vIGJlY2F1c2UgdGhlIGRhdGEgc3RydWN0dXJlIGlzIEFMTCBub2RlcywganVzdCBmbGF0dGVuZWQsIGRvbid0IGp1c3QgYXBwbHkgYXQgdGhlIHRvcCBsZXZlbFxuICAvLyB0aGVuIGV2ZXJ5dGhpbmcgc2hvdWxkIGhhdmUgYW4gWFxuICAvLyBUSEVOLCBmb3IgdGhlIFlcbiAgLy8gZG8gdGhlIHNhbWUgdGhpbmcsIHRoaXMgdGltZSBvbiB0aGUgZ3JvdXBpbmcgb2YgOCEgaS5lLiA4IGRpZmZlcmVudCBZIHZhbHVlcywgbm90IGxvYWRzIG9mIGRpZmZlcmVudCBvbmVzIVxuICBmdW5jdGlvbiBjb21wdXRlTm9kZUJyZWFkdGhzKGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICB2YXIgbm9kZXNCeUJyZWFkdGggPSBkMy5uZXN0KClcbiAgICAgICAgLmtleShmdW5jdGlvbihkKSB7IHJldHVybiBkLnk7IH0pXG4gICAgICAgIC5zb3J0S2V5cyhkMy5hc2NlbmRpbmcpXG4gICAgICAgIC5lbnRyaWVzKG5vZGVzKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzOyB9KTsgLy8gdmFsdWVzISB3ZSBhcmUgdXNpbmcgdGhlIHZhbHVlcyBhbHNvIGFzIGEgd2F5IHRvIHNlcGVyYXRlIG5vZGVzIChub3QganVzdCBzdHJva2Ugd2lkdGgpP1xuXG4gICAgICAvLyB0aGlzIGJpdCBpcyBhY3R1YWxseSB0aGUgbm9kZSBzaXplcyAod2lkdGhzKVxuICAgICAgLy92YXIga3kgPSAoc2l6ZVsxXSAtIChub2Rlcy5sZW5ndGggLSAxKSAqIG5vZGVQYWRkaW5nKSAvIGQzLnN1bShub2RlcywgdmFsdWUpXG4gICAgICAvLyB0aGlzIHNob3VsZCBiZSBvbmx5IHNvdXJjZSBub2RlcyBzdXJlbHkgKGxldmVsIDEpXG4gICAgICB2YXIga3kgPSAoc2l6ZVswXSAtIChub2Rlc0J5QnJlYWR0aFswXS5sZW5ndGggLSAxKSAqIG5vZGVQYWRkaW5nKSAvIGQzLnN1bShub2Rlc0J5QnJlYWR0aFswXSwgdmFsdWUpO1xuICAgICAgLy8gSSdkIGxpa2UgdGhlbSB0byBiZSBtdWNoIGJpZ2dlciwgdGhpcyBjYWxjIGRvZXNuJ3Qgc2VlbSB0byBmaWxsIHRoZSBzcGFjZSE/XG5cbiAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlLCBpKSB7XG4gICAgICAgICAgbm9kZS54ID0gaTtcbiAgICAgICAgICBub2RlLmR5ID0gbm9kZS52YWx1ZSAqIGt5O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICBsaW5rLmR5ID0gbGluay52YWx1ZSAqIGt5O1xuICAgICAgfSk7XG5cbiAgICAgIHJlc29sdmVDb2xsaXNpb25zKCk7XG5cbiAgICAgIGZvciAodmFyIGFscGhhID0gMTsgaXRlcmF0aW9ucyA+IDA7IC0taXRlcmF0aW9ucykge1xuICAgICAgICByZWxheExlZnRUb1JpZ2h0KGFscGhhKTtcbiAgICAgICAgcmVzb2x2ZUNvbGxpc2lvbnMoKTtcblxuICAgICAgICByZWxheFJpZ2h0VG9MZWZ0KGFscGhhICo9IC45OSk7XG4gICAgICAgIHJlc29sdmVDb2xsaXNpb25zKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZXNlIHJlbGF4IG1ldGhvZHMgc2hvdWxkIHByb2JhYmx5IGJlIG9wZXJhdGluZyBvbiBvbmUgbGV2ZWwgb2YgdGhlIG5vZGVzLCBub3QgYWxsIT9cblxuICAgICAgZnVuY3Rpb24gcmVsYXhMZWZ0VG9SaWdodChhbHBoYSkge1xuICAgICAgICBub2Rlc0J5QnJlYWR0aC5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVzLCBicmVhZHRoKSB7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YXJnZXRMaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBkMy5zdW0obm9kZS50YXJnZXRMaW5rcywgd2VpZ2h0ZWRTb3VyY2UpIC8gZDMuc3VtKG5vZGUudGFyZ2V0TGlua3MsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS54ICs9ICh5IC0gY2VudGVyKG5vZGUpKSAqIGFscGhhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gd2VpZ2h0ZWRTb3VyY2UobGluaykge1xuICAgICAgICByZXR1cm4gY2VudGVyKGxpbmsuc291cmNlKSAqIGxpbmsudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXhSaWdodFRvTGVmdChhbHBoYSkge1xuICAgICAgbm9kZXNCeUJyZWFkdGguc2xpY2UoKS5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbihub2Rlcykge1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5zb3VyY2VMaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB5ID0gZDMuc3VtKG5vZGUuc291cmNlTGlua3MsIHdlaWdodGVkVGFyZ2V0KSAvIGQzLnN1bShub2RlLnNvdXJjZUxpbmtzLCB2YWx1ZSk7XG4gICAgICAgICAgICBub2RlLnggKz0gKHkgLSBjZW50ZXIobm9kZSkpICogYWxwaGE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiB3ZWlnaHRlZFRhcmdldChsaW5rKSB7XG4gICAgICAgIHJldHVybiBjZW50ZXIobGluay50YXJnZXQpICogbGluay52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVDb2xsaXNpb25zKCkge1xuICAgICAgICBub2Rlc0J5QnJlYWR0aC5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICAgICAgZHksXG4gICAgICAgICAgICAgIHgwID0gMCxcbiAgICAgICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgLy8gUHVzaCBhbnkgb3ZlcmxhcHBpbmcgbm9kZXMgcmlnaHQuXG4gICAgICAgICAgICBub2Rlcy5zb3J0KGFzY2VuZGluZ0RlcHRoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgZHkgPSB4MCAtIG5vZGUueDtcbiAgICAgICAgICAgICAgICBpZiAoZHkgPiAwKSBub2RlLnggKz0gZHk7XG4gICAgICAgICAgICAgICAgeDAgPSBub2RlLnggKyBub2RlLmR5ICsgbm9kZVBhZGRpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSByaWdodG1vc3Qgbm9kZSBnb2VzIG91dHNpZGUgdGhlIGJvdW5kcywgcHVzaCBpdCBsZWZ0LlxuICAgICAgICAgICAgZHkgPSB4MCAtIG5vZGVQYWRkaW5nIC0gc2l6ZVswXTsgLy8gd2FzIHNpemVbMV1cbiAgICAgICAgICAgIGlmIChkeSA+IDApIHtcbiAgICAgICAgICAgICAgICB4MCA9IG5vZGUueCAtPSBkeTtcblxuICAgICAgICAgICAgICAgIC8vIFB1c2ggYW55IG92ZXJsYXBwaW5nIG5vZGVzIGxlZnQuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZHkgPSBub2RlLnggKyBub2RlLmR5ICsgbm9kZVBhZGRpbmcgLSB4MDsgLy8gd2FzIHkwXG4gICAgICAgICAgICAgICAgICAgIGlmIChkeSA+IDApIG5vZGUueCAtPSBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gbm9kZS54O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXNjZW5kaW5nRGVwdGgoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLnggLSBiLng7IC8vIGxlZnQgc29ydFxuICAgICAgICAgIC8vIHJldHVybiBiLnggLSBhLng7IC8vIHJpZ2h0IHNvcnRcbiAgICAgIH1cbiAgICB9XG5cbiAgLy8gdGhpcyBtb3ZlcyBhbGwgZW5kIHBvaW50cyAoc2lua3MhKSB0byB0aGUgbW9zdCBleHRyZW1lIGJvdHRvbVxuICBmdW5jdGlvbiBtb3ZlU2lua3NEb3duKHkpIHtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZS5zb3VyY2VMaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgbm9kZS55ID0geSAtIDE7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBzaGlmdCB0aGVpciBsb2NhdGlvbnMgb3V0IHRvIG9jY3VweSB0aGUgc2NyZWVuXG4gIGZ1bmN0aW9uIHNjYWxlTm9kZUJyZWFkdGhzKGt4KSB7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnkgKj0ga3g7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlTm9kZURlcHRocygpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ05vZGVzID0gbm9kZXMsXG4gICAgICAgIG5leHROb2RlcyxcbiAgICAgICAgeSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHJlbWFpbmluZ05vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIG5leHROb2RlcyA9IFtdO1xuICAgICAgICAgIHJlbWFpbmluZ05vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgbm9kZS55ID0geTtcbiAgICAgICAgICAgIC8vbm9kZS5keCA9IG5vZGVXaWR0aDtcbiAgICAgICAgICAgIG5vZGUuc291cmNlTGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgICAgIGlmIChuZXh0Tm9kZXMuaW5kZXhPZihsaW5rLnRhcmdldCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbmV4dE5vZGVzLnB1c2gobGluay50YXJnZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZW1haW5pbmdOb2RlcyA9IG5leHROb2RlcztcbiAgICAgICAgICArK3k7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIGVuZCBwb2ludHMgdG8gdGhlIHZlcnkgYm90dG9tXG4gICAgICAgIG1vdmVTaW5rc0Rvd24oeSk7XG5cbiAgICAgICAgc2NhbGVOb2RlQnJlYWR0aHMoKHNpemVbMV0gLSBub2RlV2lkdGgpIC8gKHkgLSAxKSk7XG4gICAgfVxuXG4gIC8vIC50eSBpcyB0aGUgb2Zmc2V0IGluIHRlcm1zIG9mIG5vZGUgcG9zaXRpb24gb2YgdGhlIGxpbmsgKHRhcmdldClcbiAgZnVuY3Rpb24gY29tcHV0ZUxpbmtEZXB0aHMoKSB7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnNvdXJjZUxpbmtzLnNvcnQoYXNjZW5kaW5nVGFyZ2V0RGVwdGgpO1xuICAgICAgbm9kZS50YXJnZXRMaW5rcy5zb3J0KGFzY2VuZGluZ1NvdXJjZURlcHRoKTtcbiAgICB9KTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBzeSA9IDAsIHR5ID0gMDtcbiAgICAgICAgICAvL3R5ID0gbm9kZS5keTtcbiAgICAgIG5vZGUuc291cmNlTGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgIGxpbmsuc3kgPSBzeTtcbiAgICAgICAgc3kgKz0gbGluay5keTtcbiAgICAgIH0pO1xuICAgICAgbm9kZS50YXJnZXRMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIHNpbXBseSBzYXlpbmcsIGZvciBlYWNoIHRhcmdldCwga2VlcCBhZGRpbmcgdGhlIHdpZHRoIG9mIHRoZSBsaW5rXG4gICAgICAgICAgLy8gc28gd2hhdCBpZiBpdCB3YXMgdGhlIG90aGVyIHdheSByb3VuZC4gc3RhcnQgd2l0aCBmdWxsIHdpZHRoIHRoZW4gc3VidHJhY3Q/XG4gICAgICAgIGxpbmsudHkgPSB0eTtcbiAgICAgICAgdHkgKz0gbGluay5keTtcbiAgICAgICAgLy90eSAtPSBsaW5rLmR5O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhc2NlbmRpbmdTb3VyY2VEZXB0aChhLCBiKSB7XG4gICAgICAvLyByZXR1cm4gYS5zb3VyY2UueSAtIGIuc291cmNlLnk7XG4gICAgICByZXR1cm4gYS5zb3VyY2UueCAtIGIuc291cmNlLng7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNjZW5kaW5nVGFyZ2V0RGVwdGgoYSwgYikge1xuICAgICAgLy9yZXR1cm4gYS50YXJnZXQueSAtIGIudGFyZ2V0Lnk7XG4gICAgICAgIHJldHVybiBhLnRhcmdldC54IC0gYi50YXJnZXQueDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjZW50ZXIobm9kZSkge1xuICAgIHJldHVybiAwOyAvLyBBbHRlcmFjacOzbiBkZWwgY29kaWdvXG4gICAgLy8gcmV0dXJuIG5vZGUueSArIG5vZGUuZHkgLyAyO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsdWUobGluaykge1xuICAgIHJldHVybiBsaW5rLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHNhbmtleTtcbn07XG4iXX0=
